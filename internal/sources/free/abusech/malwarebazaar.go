package abusech

import (
	"bufio"
	"context"
	"encoding/csv"
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/google/uuid"

	"orbguard-lab/internal/domain/models"
	"orbguard-lab/internal/sources"
	"orbguard-lab/pkg/logger"
)

const (
	malwareBazaarCSVURL = "https://bazaar.abuse.ch/export/csv/recent/"
	malwareBazaarSlug   = "malwarebazaar"
)

// MalwareBazaarConnector fetches malware samples from Abuse.ch MalwareBazaar
type MalwareBazaarConnector struct {
	*sources.BaseConnector
	client *http.Client
	logger *logger.Logger
}

// NewMalwareBazaarConnector creates a new MalwareBazaar connector
func NewMalwareBazaarConnector(log *logger.Logger) *MalwareBazaarConnector {
	return &MalwareBazaarConnector{
		BaseConnector: sources.NewBaseConnector(
			malwareBazaarSlug,
			"MalwareBazaar",
			models.SourceCategoryAbuseCH,
			models.SourceTypeAPI,
		),
		client: &http.Client{
			Timeout: 120 * time.Second, // Larger timeout for big CSV
		},
		logger: log.WithComponent("malwarebazaar"),
	}
}

// Fetch retrieves malware samples from MalwareBazaar CSV feed
func (c *MalwareBazaarConnector) Fetch(ctx context.Context) (*models.SourceFetchResult, error) {
	start := time.Now()

	result := &models.SourceFetchResult{
		SourceID:      uuid.Nil,
		SourceSlug:    c.Slug(),
		FetchedAt:     start,
		RawIndicators: make([]models.RawIndicator, 0),
	}

	req, err := http.NewRequestWithContext(ctx, "GET", malwareBazaarCSVURL, nil)
	if err != nil {
		result.Error = err
		return result, err
	}

	c.logger.Info().Str("url", malwareBazaarCSVURL).Msg("fetching MalwareBazaar CSV feed")

	resp, err := c.client.Do(req)
	if err != nil {
		result.Error = err
		return result, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		err = fmt.Errorf("unexpected status code: %d", resp.StatusCode)
		result.Error = err
		return result, err
	}

	// Parse CSV (skip comment lines starting with #)
	scanner := bufio.NewScanner(resp.Body)
	var csvLines []string
	for scanner.Scan() {
		line := scanner.Text()
		if !strings.HasPrefix(line, "#") && len(line) > 0 {
			csvLines = append(csvLines, line)
		}
	}

	if len(csvLines) == 0 {
		c.logger.Warn().Msg("no data in MalwareBazaar feed")
		result.Success = true
		result.Duration = time.Since(start)
		return result, nil
	}

	// Parse CSV data
	// Format: first_seen_utc,sha256_hash,md5_hash,sha1_hash,reporter,file_name,file_type_guess,mime_type,signature,clamav,vtpercent,imphash,ssdeep,tlsh
	reader := csv.NewReader(strings.NewReader(strings.Join(csvLines, "\n")))
	records, err := reader.ReadAll()
	if err != nil {
		result.Error = err
		return result, err
	}

	c.logger.Info().Int("records", len(records)).Msg("parsing MalwareBazaar CSV")

	for _, record := range records {
		if len(record) < 10 {
			continue
		}

		// Parse fields
		firstSeenStr := record[0]
		sha256Hash := record[1]
		md5Hash := record[2]
		sha1Hash := record[3]
		reporter := record[4]
		fileName := record[5]
		fileType := record[6]
		mimeType := record[7]
		signature := record[8]

		// Skip header row
		if sha256Hash == "sha256_hash" {
			continue
		}

		// Parse date
		var firstSeen *time.Time
		if t, err := time.Parse("2006-01-02 15:04:05", firstSeenStr); err == nil {
			firstSeen = &t
		}

		// Build tags
		tags := []string{"malwarebazaar", "malware"}
		if signature != "" && signature != "n/a" {
			tags = append(tags, strings.ToLower(signature))
		}
		if fileType != "" {
			tags = append(tags, strings.ToLower(fileType))
		}

		// Determine severity based on signature
		severity := models.SeverityHigh
		if strings.Contains(strings.ToLower(signature), "ransomware") {
			severity = models.SeverityCritical
		}

		confidence := 0.90

		// Add SHA256 indicator (primary)
		if sha256Hash != "" {
			result.RawIndicators = append(result.RawIndicators, models.RawIndicator{
				Value:       strings.ToLower(sha256Hash),
				Type:        models.IndicatorTypeHash,
				Severity:    severity,
				Confidence:  &confidence,
				Description: fmt.Sprintf("MalwareBazaar: %s (%s)", signature, fileName),
				Tags:        append(tags, "sha256"),
				FirstSeen:   firstSeen,
				SourceID:    c.Slug(),
				SourceName:  c.Name(),
				RawData: map[string]any{
					"sha256":    sha256Hash,
					"md5":       md5Hash,
					"sha1":      sha1Hash,
					"file_name": fileName,
					"file_type": fileType,
					"mime_type": mimeType,
					"signature": signature,
					"reporter":  reporter,
				},
			})
		}

		// Add MD5 indicator
		if md5Hash != "" {
			md5Confidence := 0.85
			result.RawIndicators = append(result.RawIndicators, models.RawIndicator{
				Value:       strings.ToLower(md5Hash),
				Type:        models.IndicatorTypeHash,
				Severity:    severity,
				Confidence:  &md5Confidence,
				Description: fmt.Sprintf("MalwareBazaar MD5: %s", signature),
				Tags:        append(tags, "md5"),
				FirstSeen:   firstSeen,
				SourceID:    c.Slug(),
				SourceName:  c.Name(),
			})
		}

		// Add SHA1 indicator
		if sha1Hash != "" {
			sha1Confidence := 0.85
			result.RawIndicators = append(result.RawIndicators, models.RawIndicator{
				Value:       strings.ToLower(sha1Hash),
				Type:        models.IndicatorTypeHash,
				Severity:    severity,
				Confidence:  &sha1Confidence,
				Description: fmt.Sprintf("MalwareBazaar SHA1: %s", signature),
				Tags:        append(tags, "sha1"),
				FirstSeen:   firstSeen,
				SourceID:    c.Slug(),
				SourceName:  c.Name(),
			})
		}
	}

	result.Success = true
	result.TotalFetched = len(result.RawIndicators)
	result.Duration = time.Since(start)

	c.logger.Info().
		Int("records", len(records)).
		Int("indicators", len(result.RawIndicators)).
		Dur("duration", result.Duration).
		Msg("MalwareBazaar fetch completed")

	return result, nil
}
