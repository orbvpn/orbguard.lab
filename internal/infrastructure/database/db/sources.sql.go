// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sources.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"orbguard-lab/internal/domain/models"
)

const countActiveSources = `-- name: CountActiveSources :one
SELECT COUNT(*) FROM sources WHERE status = 'active'
`

func (q *Queries) CountActiveSources(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countActiveSources)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSources = `-- name: CountSources :one
SELECT COUNT(*) FROM sources
`

func (q *Queries) CountSources(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countSources)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createSource = `-- name: CreateSource :one
INSERT INTO sources (
    name, slug, description, category, type, status,
    api_url, feed_url, github_urls, requires_api_key,
    reliability, weight, update_interval
) VALUES (
    $1, $2, $3, $4, $5, $6,
    $7, $8, $9, $10,
    $11, $12, $13
)
RETURNING id, name, slug, description, category, type, status, api_url, feed_url, github_urls, requires_api_key, reliability, weight, update_interval, last_fetched, next_fetch, last_error, error_count, indicator_count, last_indicator_at, created_at, updated_at
`

type CreateSourceParams struct {
	Name           string                `db:"name" json:"name"`
	Slug           string                `db:"slug" json:"slug"`
	Description    pgtype.Text           `db:"description" json:"description"`
	Category       models.SourceCategory `db:"category" json:"category"`
	Type           models.SourceType     `db:"type" json:"type"`
	Status         models.SourceStatus   `db:"status" json:"status"`
	ApiUrl         pgtype.Text           `db:"api_url" json:"api_url"`
	FeedUrl        pgtype.Text           `db:"feed_url" json:"feed_url"`
	GithubUrls     []string              `db:"github_urls" json:"github_urls"`
	RequiresApiKey bool                  `db:"requires_api_key" json:"requires_api_key"`
	Reliability    pgtype.Numeric        `db:"reliability" json:"reliability"`
	Weight         pgtype.Numeric        `db:"weight" json:"weight"`
	UpdateInterval pgtype.Interval       `db:"update_interval" json:"update_interval"`
}

func (q *Queries) CreateSource(ctx context.Context, arg *CreateSourceParams) (*Source, error) {
	row := q.db.QueryRow(ctx, createSource,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.Category,
		arg.Type,
		arg.Status,
		arg.ApiUrl,
		arg.FeedUrl,
		arg.GithubUrls,
		arg.RequiresApiKey,
		arg.Reliability,
		arg.Weight,
		arg.UpdateInterval,
	)
	var i Source
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Category,
		&i.Type,
		&i.Status,
		&i.ApiUrl,
		&i.FeedUrl,
		&i.GithubUrls,
		&i.RequiresApiKey,
		&i.Reliability,
		&i.Weight,
		&i.UpdateInterval,
		&i.LastFetched,
		&i.NextFetch,
		&i.LastError,
		&i.ErrorCount,
		&i.IndicatorCount,
		&i.LastIndicatorAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const deleteSource = `-- name: DeleteSource :exec
DELETE FROM sources WHERE id = $1
`

func (q *Queries) DeleteSource(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteSource, id)
	return err
}

const getSourceByID = `-- name: GetSourceByID :one
SELECT id, name, slug, description, category, type, status, api_url, feed_url, github_urls, requires_api_key, reliability, weight, update_interval, last_fetched, next_fetch, last_error, error_count, indicator_count, last_indicator_at, created_at, updated_at FROM sources WHERE id = $1
`

func (q *Queries) GetSourceByID(ctx context.Context, id uuid.UUID) (*Source, error) {
	row := q.db.QueryRow(ctx, getSourceByID, id)
	var i Source
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Category,
		&i.Type,
		&i.Status,
		&i.ApiUrl,
		&i.FeedUrl,
		&i.GithubUrls,
		&i.RequiresApiKey,
		&i.Reliability,
		&i.Weight,
		&i.UpdateInterval,
		&i.LastFetched,
		&i.NextFetch,
		&i.LastError,
		&i.ErrorCount,
		&i.IndicatorCount,
		&i.LastIndicatorAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getSourceBySlug = `-- name: GetSourceBySlug :one
SELECT id, name, slug, description, category, type, status, api_url, feed_url, github_urls, requires_api_key, reliability, weight, update_interval, last_fetched, next_fetch, last_error, error_count, indicator_count, last_indicator_at, created_at, updated_at FROM sources WHERE slug = $1
`

func (q *Queries) GetSourceBySlug(ctx context.Context, slug string) (*Source, error) {
	row := q.db.QueryRow(ctx, getSourceBySlug, slug)
	var i Source
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Category,
		&i.Type,
		&i.Status,
		&i.ApiUrl,
		&i.FeedUrl,
		&i.GithubUrls,
		&i.RequiresApiKey,
		&i.Reliability,
		&i.Weight,
		&i.UpdateInterval,
		&i.LastFetched,
		&i.NextFetch,
		&i.LastError,
		&i.ErrorCount,
		&i.IndicatorCount,
		&i.LastIndicatorAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const incrementSourceIndicatorCount = `-- name: IncrementSourceIndicatorCount :exec
UPDATE sources
SET
    indicator_count = indicator_count + $2,
    last_indicator_at = NOW(),
    updated_at = NOW()
WHERE id = $1
`

type IncrementSourceIndicatorCountParams struct {
	ID             uuid.UUID `db:"id" json:"id"`
	IndicatorCount int32     `db:"indicator_count" json:"indicator_count"`
}

func (q *Queries) IncrementSourceIndicatorCount(ctx context.Context, arg *IncrementSourceIndicatorCountParams) error {
	_, err := q.db.Exec(ctx, incrementSourceIndicatorCount, arg.ID, arg.IndicatorCount)
	return err
}

const listActiveSources = `-- name: ListActiveSources :many
SELECT id, name, slug, description, category, type, status, api_url, feed_url, github_urls, requires_api_key, reliability, weight, update_interval, last_fetched, next_fetch, last_error, error_count, indicator_count, last_indicator_at, created_at, updated_at FROM sources
WHERE status = 'active'
ORDER BY name ASC
`

func (q *Queries) ListActiveSources(ctx context.Context) ([]*Source, error) {
	rows, err := q.db.Query(ctx, listActiveSources)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Source{}
	for rows.Next() {
		var i Source
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.Category,
			&i.Type,
			&i.Status,
			&i.ApiUrl,
			&i.FeedUrl,
			&i.GithubUrls,
			&i.RequiresApiKey,
			&i.Reliability,
			&i.Weight,
			&i.UpdateInterval,
			&i.LastFetched,
			&i.NextFetch,
			&i.LastError,
			&i.ErrorCount,
			&i.IndicatorCount,
			&i.LastIndicatorAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSources = `-- name: ListSources :many
SELECT id, name, slug, description, category, type, status, api_url, feed_url, github_urls, requires_api_key, reliability, weight, update_interval, last_fetched, next_fetch, last_error, error_count, indicator_count, last_indicator_at, created_at, updated_at FROM sources
ORDER BY name ASC
`

func (q *Queries) ListSources(ctx context.Context) ([]*Source, error) {
	rows, err := q.db.Query(ctx, listSources)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Source{}
	for rows.Next() {
		var i Source
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.Category,
			&i.Type,
			&i.Status,
			&i.ApiUrl,
			&i.FeedUrl,
			&i.GithubUrls,
			&i.RequiresApiKey,
			&i.Reliability,
			&i.Weight,
			&i.UpdateInterval,
			&i.LastFetched,
			&i.NextFetch,
			&i.LastError,
			&i.ErrorCount,
			&i.IndicatorCount,
			&i.LastIndicatorAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSourcesByCategory = `-- name: ListSourcesByCategory :many
SELECT id, name, slug, description, category, type, status, api_url, feed_url, github_urls, requires_api_key, reliability, weight, update_interval, last_fetched, next_fetch, last_error, error_count, indicator_count, last_indicator_at, created_at, updated_at FROM sources
WHERE category = $1
ORDER BY name ASC
`

func (q *Queries) ListSourcesByCategory(ctx context.Context, category models.SourceCategory) ([]*Source, error) {
	rows, err := q.db.Query(ctx, listSourcesByCategory, category)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Source{}
	for rows.Next() {
		var i Source
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.Category,
			&i.Type,
			&i.Status,
			&i.ApiUrl,
			&i.FeedUrl,
			&i.GithubUrls,
			&i.RequiresApiKey,
			&i.Reliability,
			&i.Weight,
			&i.UpdateInterval,
			&i.LastFetched,
			&i.NextFetch,
			&i.LastError,
			&i.ErrorCount,
			&i.IndicatorCount,
			&i.LastIndicatorAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSourcesDueForUpdate = `-- name: ListSourcesDueForUpdate :many
SELECT id, name, slug, description, category, type, status, api_url, feed_url, github_urls, requires_api_key, reliability, weight, update_interval, last_fetched, next_fetch, last_error, error_count, indicator_count, last_indicator_at, created_at, updated_at FROM sources
WHERE status = 'active'
  AND (next_fetch IS NULL OR next_fetch <= NOW())
ORDER BY next_fetch ASC NULLS FIRST
LIMIT $1
`

func (q *Queries) ListSourcesDueForUpdate(ctx context.Context, limit int32) ([]*Source, error) {
	rows, err := q.db.Query(ctx, listSourcesDueForUpdate, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Source{}
	for rows.Next() {
		var i Source
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.Category,
			&i.Type,
			&i.Status,
			&i.ApiUrl,
			&i.FeedUrl,
			&i.GithubUrls,
			&i.RequiresApiKey,
			&i.Reliability,
			&i.Weight,
			&i.UpdateInterval,
			&i.LastFetched,
			&i.NextFetch,
			&i.LastError,
			&i.ErrorCount,
			&i.IndicatorCount,
			&i.LastIndicatorAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resetSourceErrors = `-- name: ResetSourceErrors :exec
UPDATE sources
SET
    last_error = NULL,
    error_count = 0,
    status = 'active',
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) ResetSourceErrors(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, resetSourceErrors, id)
	return err
}

const updateSourceAfterFetch = `-- name: UpdateSourceAfterFetch :exec
UPDATE sources
SET
    last_fetched = NOW(),
    next_fetch = NOW() + update_interval,
    last_error = NULL,
    error_count = 0,
    updated_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdateSourceAfterFetch(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, updateSourceAfterFetch, id)
	return err
}

const updateSourceError = `-- name: UpdateSourceError :exec
UPDATE sources
SET
    last_error = $2,
    error_count = error_count + 1,
    next_fetch = NOW() + update_interval,
    status = CASE WHEN error_count >= 5 THEN 'error'::source_status ELSE status END,
    updated_at = NOW()
WHERE id = $1
`

type UpdateSourceErrorParams struct {
	ID        uuid.UUID   `db:"id" json:"id"`
	LastError pgtype.Text `db:"last_error" json:"last_error"`
}

func (q *Queries) UpdateSourceError(ctx context.Context, arg *UpdateSourceErrorParams) error {
	_, err := q.db.Exec(ctx, updateSourceError, arg.ID, arg.LastError)
	return err
}

const updateSourceIndicatorCount = `-- name: UpdateSourceIndicatorCount :exec
UPDATE sources
SET
    indicator_count = $2,
    last_indicator_at = NOW(),
    updated_at = NOW()
WHERE id = $1
`

type UpdateSourceIndicatorCountParams struct {
	ID             uuid.UUID `db:"id" json:"id"`
	IndicatorCount int32     `db:"indicator_count" json:"indicator_count"`
}

func (q *Queries) UpdateSourceIndicatorCount(ctx context.Context, arg *UpdateSourceIndicatorCountParams) error {
	_, err := q.db.Exec(ctx, updateSourceIndicatorCount, arg.ID, arg.IndicatorCount)
	return err
}

const updateSourceStatus = `-- name: UpdateSourceStatus :exec
UPDATE sources
SET status = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateSourceStatusParams struct {
	ID     uuid.UUID           `db:"id" json:"id"`
	Status models.SourceStatus `db:"status" json:"status"`
}

func (q *Queries) UpdateSourceStatus(ctx context.Context, arg *UpdateSourceStatusParams) error {
	_, err := q.db.Exec(ctx, updateSourceStatus, arg.ID, arg.Status)
	return err
}
