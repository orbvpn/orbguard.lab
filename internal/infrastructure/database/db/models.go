// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package db

import (
	"database/sql/driver"
	"fmt"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"orbguard-lab/internal/domain/models"
)

type CampaignStatus string

const (
	CampaignStatusActive   CampaignStatus = "active"
	CampaignStatusInactive CampaignStatus = "inactive"
	CampaignStatusHistoric CampaignStatus = "historic"
)

func (e *CampaignStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CampaignStatus(s)
	case string:
		*e = CampaignStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for CampaignStatus: %T", src)
	}
	return nil
}

type NullCampaignStatus struct {
	CampaignStatus CampaignStatus `json:"campaign_status"`
	Valid          bool           `json:"valid"` // Valid is true if CampaignStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCampaignStatus) Scan(value interface{}) error {
	if value == nil {
		ns.CampaignStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CampaignStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCampaignStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CampaignStatus), nil
}

type IndicatorType string

const (
	IndicatorTypeDomain      IndicatorType = "domain"
	IndicatorTypeIp          IndicatorType = "ip"
	IndicatorTypeIpv6        IndicatorType = "ipv6"
	IndicatorTypeHash        IndicatorType = "hash"
	IndicatorTypeUrl         IndicatorType = "url"
	IndicatorTypeProcess     IndicatorType = "process"
	IndicatorTypeCertificate IndicatorType = "certificate"
	IndicatorTypePackage     IndicatorType = "package"
	IndicatorTypeEmail       IndicatorType = "email"
	IndicatorTypeFilepath    IndicatorType = "filepath"
	IndicatorTypeRegistry    IndicatorType = "registry"
	IndicatorTypeYara        IndicatorType = "yara"
)

func (e *IndicatorType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = IndicatorType(s)
	case string:
		*e = IndicatorType(s)
	default:
		return fmt.Errorf("unsupported scan type for IndicatorType: %T", src)
	}
	return nil
}

type NullIndicatorType struct {
	IndicatorType IndicatorType `json:"indicator_type"`
	Valid         bool          `json:"valid"` // Valid is true if IndicatorType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullIndicatorType) Scan(value interface{}) error {
	if value == nil {
		ns.IndicatorType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.IndicatorType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullIndicatorType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.IndicatorType), nil
}

type PlatformType string

const (
	PlatformTypeAndroid PlatformType = "android"
	PlatformTypeIos     PlatformType = "ios"
	PlatformTypeWindows PlatformType = "windows"
	PlatformTypeMacos   PlatformType = "macos"
	PlatformTypeLinux   PlatformType = "linux"
	PlatformTypeAll     PlatformType = "all"
)

func (e *PlatformType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PlatformType(s)
	case string:
		*e = PlatformType(s)
	default:
		return fmt.Errorf("unsupported scan type for PlatformType: %T", src)
	}
	return nil
}

type NullPlatformType struct {
	PlatformType PlatformType `json:"platform_type"`
	Valid        bool         `json:"valid"` // Valid is true if PlatformType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPlatformType) Scan(value interface{}) error {
	if value == nil {
		ns.PlatformType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PlatformType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPlatformType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PlatformType), nil
}

type ReportStatus string

const (
	ReportStatusPending   ReportStatus = "pending"
	ReportStatusReviewing ReportStatus = "reviewing"
	ReportStatusApproved  ReportStatus = "approved"
	ReportStatusRejected  ReportStatus = "rejected"
	ReportStatusDuplicate ReportStatus = "duplicate"
)

func (e *ReportStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ReportStatus(s)
	case string:
		*e = ReportStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for ReportStatus: %T", src)
	}
	return nil
}

type NullReportStatus struct {
	ReportStatus ReportStatus `json:"report_status"`
	Valid        bool         `json:"valid"` // Valid is true if ReportStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullReportStatus) Scan(value interface{}) error {
	if value == nil {
		ns.ReportStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ReportStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullReportStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ReportStatus), nil
}

type SeverityLevel string

const (
	SeverityLevelCritical SeverityLevel = "critical"
	SeverityLevelHigh     SeverityLevel = "high"
	SeverityLevelMedium   SeverityLevel = "medium"
	SeverityLevelLow      SeverityLevel = "low"
	SeverityLevelInfo     SeverityLevel = "info"
)

func (e *SeverityLevel) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SeverityLevel(s)
	case string:
		*e = SeverityLevel(s)
	default:
		return fmt.Errorf("unsupported scan type for SeverityLevel: %T", src)
	}
	return nil
}

type NullSeverityLevel struct {
	SeverityLevel SeverityLevel `json:"severity_level"`
	Valid         bool          `json:"valid"` // Valid is true if SeverityLevel is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSeverityLevel) Scan(value interface{}) error {
	if value == nil {
		ns.SeverityLevel, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SeverityLevel.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSeverityLevel) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SeverityLevel), nil
}

type SourceCategory string

const (
	SourceCategoryAbuseCh      SourceCategory = "abuse_ch"
	SourceCategoryPhishing     SourceCategory = "phishing"
	SourceCategoryIpReputation SourceCategory = "ip_reputation"
	SourceCategoryMobile       SourceCategory = "mobile"
	SourceCategoryGeneral      SourceCategory = "general"
	SourceCategoryGovernment   SourceCategory = "government"
	SourceCategoryIsac         SourceCategory = "isac"
	SourceCategoryCommunity    SourceCategory = "community"
	SourceCategoryPremium      SourceCategory = "premium"
)

func (e *SourceCategory) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SourceCategory(s)
	case string:
		*e = SourceCategory(s)
	default:
		return fmt.Errorf("unsupported scan type for SourceCategory: %T", src)
	}
	return nil
}

type NullSourceCategory struct {
	SourceCategory SourceCategory `json:"source_category"`
	Valid          bool           `json:"valid"` // Valid is true if SourceCategory is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSourceCategory) Scan(value interface{}) error {
	if value == nil {
		ns.SourceCategory, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SourceCategory.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSourceCategory) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SourceCategory), nil
}

type SourceStatus string

const (
	SourceStatusActive   SourceStatus = "active"
	SourceStatusPaused   SourceStatus = "paused"
	SourceStatusError    SourceStatus = "error"
	SourceStatusDisabled SourceStatus = "disabled"
)

func (e *SourceStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SourceStatus(s)
	case string:
		*e = SourceStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for SourceStatus: %T", src)
	}
	return nil
}

type NullSourceStatus struct {
	SourceStatus SourceStatus `json:"source_status"`
	Valid        bool         `json:"valid"` // Valid is true if SourceStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSourceStatus) Scan(value interface{}) error {
	if value == nil {
		ns.SourceStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SourceStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSourceStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SourceStatus), nil
}

type SourceType string

const (
	SourceTypeApi       SourceType = "api"
	SourceTypeFeed      SourceType = "feed"
	SourceTypeGithub    SourceType = "github"
	SourceTypeTaxii     SourceType = "taxii"
	SourceTypeManual    SourceType = "manual"
	SourceTypeCommunity SourceType = "community"
)

func (e *SourceType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SourceType(s)
	case string:
		*e = SourceType(s)
	default:
		return fmt.Errorf("unsupported scan type for SourceType: %T", src)
	}
	return nil
}

type NullSourceType struct {
	SourceType SourceType `json:"source_type"`
	Valid      bool       `json:"valid"` // Valid is true if SourceType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSourceType) Scan(value interface{}) error {
	if value == nil {
		ns.SourceType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SourceType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSourceType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SourceType), nil
}

type ThreatActorMotivation string

const (
	ThreatActorMotivationEspionage    ThreatActorMotivation = "espionage"
	ThreatActorMotivationFinancial    ThreatActorMotivation = "financial"
	ThreatActorMotivationSabotage     ThreatActorMotivation = "sabotage"
	ThreatActorMotivationSurveillance ThreatActorMotivation = "surveillance"
	ThreatActorMotivationHacktivism   ThreatActorMotivation = "hacktivism"
)

func (e *ThreatActorMotivation) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ThreatActorMotivation(s)
	case string:
		*e = ThreatActorMotivation(s)
	default:
		return fmt.Errorf("unsupported scan type for ThreatActorMotivation: %T", src)
	}
	return nil
}

type NullThreatActorMotivation struct {
	ThreatActorMotivation ThreatActorMotivation `json:"threat_actor_motivation"`
	Valid                 bool                  `json:"valid"` // Valid is true if ThreatActorMotivation is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullThreatActorMotivation) Scan(value interface{}) error {
	if value == nil {
		ns.ThreatActorMotivation, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ThreatActorMotivation.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullThreatActorMotivation) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ThreatActorMotivation), nil
}

type ThreatActorType string

const (
	ThreatActorTypeNationState   ThreatActorType = "nation-state"
	ThreatActorTypeCriminal      ThreatActorType = "criminal"
	ThreatActorTypeHacktivist    ThreatActorType = "hacktivist"
	ThreatActorTypePrivateSector ThreatActorType = "private-sector"
	ThreatActorTypeUnknown       ThreatActorType = "unknown"
)

func (e *ThreatActorType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ThreatActorType(s)
	case string:
		*e = ThreatActorType(s)
	default:
		return fmt.Errorf("unsupported scan type for ThreatActorType: %T", src)
	}
	return nil
}

type NullThreatActorType struct {
	ThreatActorType ThreatActorType `json:"threat_actor_type"`
	Valid           bool            `json:"valid"` // Valid is true if ThreatActorType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullThreatActorType) Scan(value interface{}) error {
	if value == nil {
		ns.ThreatActorType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ThreatActorType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullThreatActorType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ThreatActorType), nil
}

type Campaign struct {
	ID              uuid.UUID             `db:"id" json:"id"`
	Name            string                `db:"name" json:"name"`
	Slug            string                `db:"slug" json:"slug"`
	Description     pgtype.Text           `db:"description" json:"description"`
	Status          models.CampaignStatus `db:"status" json:"status"`
	ThreatActorID   pgtype.UUID           `db:"threat_actor_id" json:"threat_actor_id"`
	TargetSectors   []string              `db:"target_sectors" json:"target_sectors"`
	TargetRegions   []string              `db:"target_regions" json:"target_regions"`
	TargetPlatforms []models.Platform     `db:"target_platforms" json:"target_platforms"`
	MitreTechniques []string              `db:"mitre_techniques" json:"mitre_techniques"`
	MitreTactics    []string              `db:"mitre_tactics" json:"mitre_tactics"`
	FirstSeen       pgtype.Timestamptz    `db:"first_seen" json:"first_seen"`
	LastSeen        pgtype.Timestamptz    `db:"last_seen" json:"last_seen"`
	StartDate       pgtype.Timestamptz    `db:"start_date" json:"start_date"`
	EndDate         pgtype.Timestamptz    `db:"end_date" json:"end_date"`
	IndicatorCount  int32                 `db:"indicator_count" json:"indicator_count"`
	References      []string              `db:"references" json:"references"`
	Metadata        []byte                `db:"metadata" json:"metadata"`
	GraphNodeID     pgtype.Text           `db:"graph_node_id" json:"graph_node_id"`
	CreatedAt       pgtype.Timestamptz    `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamptz    `db:"updated_at" json:"updated_at"`
}

type CommunityReport struct {
	ID              uuid.UUID            `db:"id" json:"id"`
	Status          models.ReportStatus  `db:"status" json:"status"`
	IndicatorValue  string               `db:"indicator_value" json:"indicator_value"`
	IndicatorType   models.IndicatorType `db:"indicator_type" json:"indicator_type"`
	Severity        models.Severity      `db:"severity" json:"severity"`
	Description     string               `db:"description" json:"description"`
	Tags            []string             `db:"tags" json:"tags"`
	ReporterHash    string               `db:"reporter_hash" json:"reporter_hash"`
	ReporterCountry pgtype.Text          `db:"reporter_country" json:"reporter_country"`
	DeviceType      pgtype.Text          `db:"device_type" json:"device_type"`
	DeviceModel     pgtype.Text          `db:"device_model" json:"device_model"`
	OsVersion       pgtype.Text          `db:"os_version" json:"os_version"`
	AppVersion      pgtype.Text          `db:"app_version" json:"app_version"`
	EvidenceData    []byte               `db:"evidence_data" json:"evidence_data"`
	ScreenshotUrl   pgtype.Text          `db:"screenshot_url" json:"screenshot_url"`
	ReviewedBy      pgtype.UUID          `db:"reviewed_by" json:"reviewed_by"`
	ReviewedAt      pgtype.Timestamptz   `db:"reviewed_at" json:"reviewed_at"`
	ReviewNotes     pgtype.Text          `db:"review_notes" json:"review_notes"`
	IndicatorID     pgtype.UUID          `db:"indicator_id" json:"indicator_id"`
	ReportedAt      pgtype.Timestamptz   `db:"reported_at" json:"reported_at"`
	CreatedAt       pgtype.Timestamptz   `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamptz   `db:"updated_at" json:"updated_at"`
}

type Indicator struct {
	ID              uuid.UUID            `db:"id" json:"id"`
	Value           string               `db:"value" json:"value"`
	ValueHash       string               `db:"value_hash" json:"value_hash"`
	Type            models.IndicatorType `db:"type" json:"type"`
	Severity        models.Severity      `db:"severity" json:"severity"`
	Confidence      pgtype.Numeric       `db:"confidence" json:"confidence"`
	Description     pgtype.Text          `db:"description" json:"description"`
	Tags            []string             `db:"tags" json:"tags"`
	Platforms       []models.Platform    `db:"platforms" json:"platforms"`
	FirstSeen       pgtype.Timestamptz   `db:"first_seen" json:"first_seen"`
	LastSeen        pgtype.Timestamptz   `db:"last_seen" json:"last_seen"`
	ExpiresAt       pgtype.Timestamptz   `db:"expires_at" json:"expires_at"`
	CampaignID      pgtype.UUID          `db:"campaign_id" json:"campaign_id"`
	ThreatActorID   pgtype.UUID          `db:"threat_actor_id" json:"threat_actor_id"`
	MalwareFamilyID pgtype.UUID          `db:"malware_family_id" json:"malware_family_id"`
	MitreTechniques []string             `db:"mitre_techniques" json:"mitre_techniques"`
	MitreTactics    []string             `db:"mitre_tactics" json:"mitre_tactics"`
	CveIds          []string             `db:"cve_ids" json:"cve_ids"`
	ReportCount     int32                `db:"report_count" json:"report_count"`
	SourceCount     int32                `db:"source_count" json:"source_count"`
	Metadata        []byte               `db:"metadata" json:"metadata"`
	GraphNodeID     pgtype.Text          `db:"graph_node_id" json:"graph_node_id"`
	CreatedAt       pgtype.Timestamptz   `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamptz   `db:"updated_at" json:"updated_at"`
}

type IndicatorSource struct {
	IndicatorID      uuid.UUID          `db:"indicator_id" json:"indicator_id"`
	SourceID         uuid.UUID          `db:"source_id" json:"source_id"`
	SourceConfidence pgtype.Numeric     `db:"source_confidence" json:"source_confidence"`
	RawData          pgtype.Text        `db:"raw_data" json:"raw_data"`
	FetchedAt        pgtype.Timestamptz `db:"fetched_at" json:"fetched_at"`
	CreatedAt        pgtype.Timestamptz `db:"created_at" json:"created_at"`
}

type MalwareFamily struct {
	ID             uuid.UUID          `db:"id" json:"id"`
	Name           string             `db:"name" json:"name"`
	Aliases        []string           `db:"aliases" json:"aliases"`
	Description    pgtype.Text        `db:"description" json:"description"`
	Type           pgtype.Text        `db:"type" json:"type"`
	Platforms      []models.Platform  `db:"platforms" json:"platforms"`
	ThreatActorID  pgtype.UUID        `db:"threat_actor_id" json:"threat_actor_id"`
	Techniques     []string           `db:"techniques" json:"techniques"`
	Capabilities   []string           `db:"capabilities" json:"capabilities"`
	IndicatorCount int32              `db:"indicator_count" json:"indicator_count"`
	CampaignCount  int32              `db:"campaign_count" json:"campaign_count"`
	FirstSeen      pgtype.Timestamptz `db:"first_seen" json:"first_seen"`
	LastSeen       pgtype.Timestamptz `db:"last_seen" json:"last_seen"`
	References     []string           `db:"references" json:"references"`
	Metadata       []byte             `db:"metadata" json:"metadata"`
	GraphNodeID    pgtype.Text        `db:"graph_node_id" json:"graph_node_id"`
	CreatedAt      pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

type Source struct {
	ID              uuid.UUID             `db:"id" json:"id"`
	Name            string                `db:"name" json:"name"`
	Slug            string                `db:"slug" json:"slug"`
	Description     pgtype.Text           `db:"description" json:"description"`
	Category        models.SourceCategory `db:"category" json:"category"`
	Type            models.SourceType     `db:"type" json:"type"`
	Status          models.SourceStatus   `db:"status" json:"status"`
	ApiUrl          pgtype.Text           `db:"api_url" json:"api_url"`
	FeedUrl         pgtype.Text           `db:"feed_url" json:"feed_url"`
	GithubUrls      []string              `db:"github_urls" json:"github_urls"`
	RequiresApiKey  bool                  `db:"requires_api_key" json:"requires_api_key"`
	Reliability     pgtype.Numeric        `db:"reliability" json:"reliability"`
	Weight          pgtype.Numeric        `db:"weight" json:"weight"`
	UpdateInterval  pgtype.Interval       `db:"update_interval" json:"update_interval"`
	LastFetched     pgtype.Timestamptz    `db:"last_fetched" json:"last_fetched"`
	NextFetch       pgtype.Timestamptz    `db:"next_fetch" json:"next_fetch"`
	LastError       pgtype.Text           `db:"last_error" json:"last_error"`
	ErrorCount      int32                 `db:"error_count" json:"error_count"`
	IndicatorCount  int32                 `db:"indicator_count" json:"indicator_count"`
	LastIndicatorAt pgtype.Timestamptz    `db:"last_indicator_at" json:"last_indicator_at"`
	CreatedAt       pgtype.Timestamptz    `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamptz    `db:"updated_at" json:"updated_at"`
}

type ThreatActor struct {
	ID               uuid.UUID                 `db:"id" json:"id"`
	Name             string                    `db:"name" json:"name"`
	Aliases          []string                  `db:"aliases" json:"aliases"`
	Description      pgtype.Text               `db:"description" json:"description"`
	Type             models.ThreatActorType    `db:"type" json:"type"`
	Motivation       NullThreatActorMotivation `db:"motivation" json:"motivation"`
	Country          pgtype.Text               `db:"country" json:"country"`
	Active           bool                      `db:"active" json:"active"`
	TargetSectors    []string                  `db:"target_sectors" json:"target_sectors"`
	TargetRegions    []string                  `db:"target_regions" json:"target_regions"`
	CommonTechniques []string                  `db:"common_techniques" json:"common_techniques"`
	CampaignCount    int32                     `db:"campaign_count" json:"campaign_count"`
	IndicatorCount   int32                     `db:"indicator_count" json:"indicator_count"`
	References       []string                  `db:"references" json:"references"`
	Metadata         []byte                    `db:"metadata" json:"metadata"`
	GraphNodeID      pgtype.Text               `db:"graph_node_id" json:"graph_node_id"`
	CreatedAt        pgtype.Timestamptz        `db:"created_at" json:"created_at"`
	UpdatedAt        pgtype.Timestamptz        `db:"updated_at" json:"updated_at"`
}

type UpdateHistory struct {
	ID                uuid.UUID          `db:"id" json:"id"`
	SourceID          uuid.UUID          `db:"source_id" json:"source_id"`
	SourceSlug        string             `db:"source_slug" json:"source_slug"`
	StartedAt         pgtype.Timestamptz `db:"started_at" json:"started_at"`
	CompletedAt       pgtype.Timestamptz `db:"completed_at" json:"completed_at"`
	Duration          pgtype.Interval    `db:"duration" json:"duration"`
	Success           bool               `db:"success" json:"success"`
	Error             pgtype.Text        `db:"error" json:"error"`
	TotalFetched      int32              `db:"total_fetched" json:"total_fetched"`
	NewIndicators     int32              `db:"new_indicators" json:"new_indicators"`
	UpdatedIndicators int32              `db:"updated_indicators" json:"updated_indicators"`
	SkippedIndicators int32              `db:"skipped_indicators" json:"skipped_indicators"`
	Metadata          []byte             `db:"metadata" json:"metadata"`
	CreatedAt         pgtype.Timestamptz `db:"created_at" json:"created_at"`
}
