// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: reports.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"orbguard-lab/internal/domain/models"
)

const approveReport = `-- name: ApproveReport :exec
UPDATE community_reports
SET
    status = 'approved',
    reviewed_by = $2,
    reviewed_at = NOW(),
    review_notes = $3,
    indicator_id = $4,
    updated_at = NOW()
WHERE id = $1
`

type ApproveReportParams struct {
	ID          uuid.UUID   `db:"id" json:"id"`
	ReviewedBy  pgtype.UUID `db:"reviewed_by" json:"reviewed_by"`
	ReviewNotes pgtype.Text `db:"review_notes" json:"review_notes"`
	IndicatorID pgtype.UUID `db:"indicator_id" json:"indicator_id"`
}

func (q *Queries) ApproveReport(ctx context.Context, arg *ApproveReportParams) error {
	_, err := q.db.Exec(ctx, approveReport,
		arg.ID,
		arg.ReviewedBy,
		arg.ReviewNotes,
		arg.IndicatorID,
	)
	return err
}

const countFailedUpdates = `-- name: CountFailedUpdates :one
SELECT COUNT(*) FROM update_history
WHERE success = FALSE
  AND started_at >= NOW() - INTERVAL '24 hours'
`

func (q *Queries) CountFailedUpdates(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countFailedUpdates)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPendingReports = `-- name: CountPendingReports :one
SELECT COUNT(*) FROM community_reports WHERE status = 'pending'
`

func (q *Queries) CountPendingReports(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countPendingReports)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countReports = `-- name: CountReports :one
SELECT COUNT(*) FROM community_reports
`

func (q *Queries) CountReports(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countReports)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countReportsByStatus = `-- name: CountReportsByStatus :one
SELECT COUNT(*) FROM community_reports WHERE status = $1
`

func (q *Queries) CountReportsByStatus(ctx context.Context, status models.ReportStatus) (int64, error) {
	row := q.db.QueryRow(ctx, countReportsByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUpdateHistory = `-- name: CountUpdateHistory :one
SELECT COUNT(*) FROM update_history
`

func (q *Queries) CountUpdateHistory(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countUpdateHistory)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createReport = `-- name: CreateReport :one
INSERT INTO community_reports (
    status, indicator_value, indicator_type, severity, description, tags,
    reporter_hash, reporter_country,
    device_type, device_model, os_version, app_version,
    evidence_data, reported_at
) VALUES (
    'pending', $1, $2, $3, $4, $5,
    $6, $7,
    $8, $9, $10, $11,
    $12, NOW()
)
RETURNING id, status, indicator_value, indicator_type, severity, description, tags, reporter_hash, reporter_country, device_type, device_model, os_version, app_version, evidence_data, screenshot_url, reviewed_by, reviewed_at, review_notes, indicator_id, reported_at, created_at, updated_at
`

type CreateReportParams struct {
	IndicatorValue  string               `db:"indicator_value" json:"indicator_value"`
	IndicatorType   models.IndicatorType `db:"indicator_type" json:"indicator_type"`
	Severity        models.Severity      `db:"severity" json:"severity"`
	Description     string               `db:"description" json:"description"`
	Tags            []string             `db:"tags" json:"tags"`
	ReporterHash    string               `db:"reporter_hash" json:"reporter_hash"`
	ReporterCountry pgtype.Text          `db:"reporter_country" json:"reporter_country"`
	DeviceType      pgtype.Text          `db:"device_type" json:"device_type"`
	DeviceModel     pgtype.Text          `db:"device_model" json:"device_model"`
	OsVersion       pgtype.Text          `db:"os_version" json:"os_version"`
	AppVersion      pgtype.Text          `db:"app_version" json:"app_version"`
	EvidenceData    []byte               `db:"evidence_data" json:"evidence_data"`
}

func (q *Queries) CreateReport(ctx context.Context, arg *CreateReportParams) (*CommunityReport, error) {
	row := q.db.QueryRow(ctx, createReport,
		arg.IndicatorValue,
		arg.IndicatorType,
		arg.Severity,
		arg.Description,
		arg.Tags,
		arg.ReporterHash,
		arg.ReporterCountry,
		arg.DeviceType,
		arg.DeviceModel,
		arg.OsVersion,
		arg.AppVersion,
		arg.EvidenceData,
	)
	var i CommunityReport
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.IndicatorValue,
		&i.IndicatorType,
		&i.Severity,
		&i.Description,
		&i.Tags,
		&i.ReporterHash,
		&i.ReporterCountry,
		&i.DeviceType,
		&i.DeviceModel,
		&i.OsVersion,
		&i.AppVersion,
		&i.EvidenceData,
		&i.ScreenshotUrl,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.ReviewNotes,
		&i.IndicatorID,
		&i.ReportedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const createUpdateHistory = `-- name: CreateUpdateHistory :one

INSERT INTO update_history (
    source_id, source_slug,
    started_at, completed_at, duration,
    success, error,
    total_fetched, new_indicators, updated_indicators, skipped_indicators,
    metadata
) VALUES (
    $1, $2,
    $3, $4, $5,
    $6, $7,
    $8, $9, $10, $11,
    $12
)
RETURNING id, source_id, source_slug, started_at, completed_at, duration, success, error, total_fetched, new_indicators, updated_indicators, skipped_indicators, metadata, created_at
`

type CreateUpdateHistoryParams struct {
	SourceID          uuid.UUID          `db:"source_id" json:"source_id"`
	SourceSlug        string             `db:"source_slug" json:"source_slug"`
	StartedAt         pgtype.Timestamptz `db:"started_at" json:"started_at"`
	CompletedAt       pgtype.Timestamptz `db:"completed_at" json:"completed_at"`
	Duration          pgtype.Interval    `db:"duration" json:"duration"`
	Success           bool               `db:"success" json:"success"`
	Error             pgtype.Text        `db:"error" json:"error"`
	TotalFetched      int32              `db:"total_fetched" json:"total_fetched"`
	NewIndicators     int32              `db:"new_indicators" json:"new_indicators"`
	UpdatedIndicators int32              `db:"updated_indicators" json:"updated_indicators"`
	SkippedIndicators int32              `db:"skipped_indicators" json:"skipped_indicators"`
	Metadata          []byte             `db:"metadata" json:"metadata"`
}

// Update History
func (q *Queries) CreateUpdateHistory(ctx context.Context, arg *CreateUpdateHistoryParams) (*UpdateHistory, error) {
	row := q.db.QueryRow(ctx, createUpdateHistory,
		arg.SourceID,
		arg.SourceSlug,
		arg.StartedAt,
		arg.CompletedAt,
		arg.Duration,
		arg.Success,
		arg.Error,
		arg.TotalFetched,
		arg.NewIndicators,
		arg.UpdatedIndicators,
		arg.SkippedIndicators,
		arg.Metadata,
	)
	var i UpdateHistory
	err := row.Scan(
		&i.ID,
		&i.SourceID,
		&i.SourceSlug,
		&i.StartedAt,
		&i.CompletedAt,
		&i.Duration,
		&i.Success,
		&i.Error,
		&i.TotalFetched,
		&i.NewIndicators,
		&i.UpdatedIndicators,
		&i.SkippedIndicators,
		&i.Metadata,
		&i.CreatedAt,
	)
	return &i, err
}

const deleteOldUpdateHistory = `-- name: DeleteOldUpdateHistory :execrows
DELETE FROM update_history
WHERE created_at < NOW() - INTERVAL '30 days'
`

func (q *Queries) DeleteOldUpdateHistory(ctx context.Context) (int64, error) {
	result, err := q.db.Exec(ctx, deleteOldUpdateHistory)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteReport = `-- name: DeleteReport :exec
DELETE FROM community_reports WHERE id = $1
`

func (q *Queries) DeleteReport(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteReport, id)
	return err
}

const getLatestUpdateBySource = `-- name: GetLatestUpdateBySource :one
SELECT id, source_id, source_slug, started_at, completed_at, duration, success, error, total_fetched, new_indicators, updated_indicators, skipped_indicators, metadata, created_at FROM update_history
WHERE source_id = $1
ORDER BY started_at DESC
LIMIT 1
`

func (q *Queries) GetLatestUpdateBySource(ctx context.Context, sourceID uuid.UUID) (*UpdateHistory, error) {
	row := q.db.QueryRow(ctx, getLatestUpdateBySource, sourceID)
	var i UpdateHistory
	err := row.Scan(
		&i.ID,
		&i.SourceID,
		&i.SourceSlug,
		&i.StartedAt,
		&i.CompletedAt,
		&i.Duration,
		&i.Success,
		&i.Error,
		&i.TotalFetched,
		&i.NewIndicators,
		&i.UpdatedIndicators,
		&i.SkippedIndicators,
		&i.Metadata,
		&i.CreatedAt,
	)
	return &i, err
}

const getReportByID = `-- name: GetReportByID :one
SELECT id, status, indicator_value, indicator_type, severity, description, tags, reporter_hash, reporter_country, device_type, device_model, os_version, app_version, evidence_data, screenshot_url, reviewed_by, reviewed_at, review_notes, indicator_id, reported_at, created_at, updated_at FROM community_reports WHERE id = $1
`

func (q *Queries) GetReportByID(ctx context.Context, id uuid.UUID) (*CommunityReport, error) {
	row := q.db.QueryRow(ctx, getReportByID, id)
	var i CommunityReport
	err := row.Scan(
		&i.ID,
		&i.Status,
		&i.IndicatorValue,
		&i.IndicatorType,
		&i.Severity,
		&i.Description,
		&i.Tags,
		&i.ReporterHash,
		&i.ReporterCountry,
		&i.DeviceType,
		&i.DeviceModel,
		&i.OsVersion,
		&i.AppVersion,
		&i.EvidenceData,
		&i.ScreenshotUrl,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.ReviewNotes,
		&i.IndicatorID,
		&i.ReportedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const listPendingReports = `-- name: ListPendingReports :many
SELECT id, status, indicator_value, indicator_type, severity, description, tags, reporter_hash, reporter_country, device_type, device_model, os_version, app_version, evidence_data, screenshot_url, reviewed_by, reviewed_at, review_notes, indicator_id, reported_at, created_at, updated_at FROM community_reports
WHERE status = 'pending'
ORDER BY reported_at ASC
LIMIT $1
`

func (q *Queries) ListPendingReports(ctx context.Context, limit int32) ([]*CommunityReport, error) {
	rows, err := q.db.Query(ctx, listPendingReports, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*CommunityReport{}
	for rows.Next() {
		var i CommunityReport
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.IndicatorValue,
			&i.IndicatorType,
			&i.Severity,
			&i.Description,
			&i.Tags,
			&i.ReporterHash,
			&i.ReporterCountry,
			&i.DeviceType,
			&i.DeviceModel,
			&i.OsVersion,
			&i.AppVersion,
			&i.EvidenceData,
			&i.ScreenshotUrl,
			&i.ReviewedBy,
			&i.ReviewedAt,
			&i.ReviewNotes,
			&i.IndicatorID,
			&i.ReportedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReports = `-- name: ListReports :many
SELECT id, status, indicator_value, indicator_type, severity, description, tags, reporter_hash, reporter_country, device_type, device_model, os_version, app_version, evidence_data, screenshot_url, reviewed_by, reviewed_at, review_notes, indicator_id, reported_at, created_at, updated_at FROM community_reports
ORDER BY reported_at DESC
LIMIT $1 OFFSET $2
`

type ListReportsParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) ListReports(ctx context.Context, arg *ListReportsParams) ([]*CommunityReport, error) {
	rows, err := q.db.Query(ctx, listReports, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*CommunityReport{}
	for rows.Next() {
		var i CommunityReport
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.IndicatorValue,
			&i.IndicatorType,
			&i.Severity,
			&i.Description,
			&i.Tags,
			&i.ReporterHash,
			&i.ReporterCountry,
			&i.DeviceType,
			&i.DeviceModel,
			&i.OsVersion,
			&i.AppVersion,
			&i.EvidenceData,
			&i.ScreenshotUrl,
			&i.ReviewedBy,
			&i.ReviewedAt,
			&i.ReviewNotes,
			&i.IndicatorID,
			&i.ReportedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReportsByStatus = `-- name: ListReportsByStatus :many
SELECT id, status, indicator_value, indicator_type, severity, description, tags, reporter_hash, reporter_country, device_type, device_model, os_version, app_version, evidence_data, screenshot_url, reviewed_by, reviewed_at, review_notes, indicator_id, reported_at, created_at, updated_at FROM community_reports
WHERE status = $1
ORDER BY reported_at DESC
LIMIT $2 OFFSET $3
`

type ListReportsByStatusParams struct {
	Status models.ReportStatus `db:"status" json:"status"`
	Limit  int32               `db:"limit" json:"limit"`
	Offset int32               `db:"offset" json:"offset"`
}

func (q *Queries) ListReportsByStatus(ctx context.Context, arg *ListReportsByStatusParams) ([]*CommunityReport, error) {
	rows, err := q.db.Query(ctx, listReportsByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*CommunityReport{}
	for rows.Next() {
		var i CommunityReport
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.IndicatorValue,
			&i.IndicatorType,
			&i.Severity,
			&i.Description,
			&i.Tags,
			&i.ReporterHash,
			&i.ReporterCountry,
			&i.DeviceType,
			&i.DeviceModel,
			&i.OsVersion,
			&i.AppVersion,
			&i.EvidenceData,
			&i.ScreenshotUrl,
			&i.ReviewedBy,
			&i.ReviewedAt,
			&i.ReviewNotes,
			&i.IndicatorID,
			&i.ReportedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUpdateHistory = `-- name: ListUpdateHistory :many
SELECT id, source_id, source_slug, started_at, completed_at, duration, success, error, total_fetched, new_indicators, updated_indicators, skipped_indicators, metadata, created_at FROM update_history
ORDER BY started_at DESC
LIMIT $1 OFFSET $2
`

type ListUpdateHistoryParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) ListUpdateHistory(ctx context.Context, arg *ListUpdateHistoryParams) ([]*UpdateHistory, error) {
	rows, err := q.db.Query(ctx, listUpdateHistory, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*UpdateHistory{}
	for rows.Next() {
		var i UpdateHistory
		if err := rows.Scan(
			&i.ID,
			&i.SourceID,
			&i.SourceSlug,
			&i.StartedAt,
			&i.CompletedAt,
			&i.Duration,
			&i.Success,
			&i.Error,
			&i.TotalFetched,
			&i.NewIndicators,
			&i.UpdatedIndicators,
			&i.SkippedIndicators,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUpdateHistoryBySource = `-- name: ListUpdateHistoryBySource :many
SELECT id, source_id, source_slug, started_at, completed_at, duration, success, error, total_fetched, new_indicators, updated_indicators, skipped_indicators, metadata, created_at FROM update_history
WHERE source_id = $1
ORDER BY started_at DESC
LIMIT $2 OFFSET $3
`

type ListUpdateHistoryBySourceParams struct {
	SourceID uuid.UUID `db:"source_id" json:"source_id"`
	Limit    int32     `db:"limit" json:"limit"`
	Offset   int32     `db:"offset" json:"offset"`
}

func (q *Queries) ListUpdateHistoryBySource(ctx context.Context, arg *ListUpdateHistoryBySourceParams) ([]*UpdateHistory, error) {
	rows, err := q.db.Query(ctx, listUpdateHistoryBySource, arg.SourceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*UpdateHistory{}
	for rows.Next() {
		var i UpdateHistory
		if err := rows.Scan(
			&i.ID,
			&i.SourceID,
			&i.SourceSlug,
			&i.StartedAt,
			&i.CompletedAt,
			&i.Duration,
			&i.Success,
			&i.Error,
			&i.TotalFetched,
			&i.NewIndicators,
			&i.UpdatedIndicators,
			&i.SkippedIndicators,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markReportAsDuplicate = `-- name: MarkReportAsDuplicate :exec
UPDATE community_reports
SET
    status = 'duplicate',
    reviewed_by = $2,
    reviewed_at = NOW(),
    review_notes = $3,
    indicator_id = $4,
    updated_at = NOW()
WHERE id = $1
`

type MarkReportAsDuplicateParams struct {
	ID          uuid.UUID   `db:"id" json:"id"`
	ReviewedBy  pgtype.UUID `db:"reviewed_by" json:"reviewed_by"`
	ReviewNotes pgtype.Text `db:"review_notes" json:"review_notes"`
	IndicatorID pgtype.UUID `db:"indicator_id" json:"indicator_id"`
}

func (q *Queries) MarkReportAsDuplicate(ctx context.Context, arg *MarkReportAsDuplicateParams) error {
	_, err := q.db.Exec(ctx, markReportAsDuplicate,
		arg.ID,
		arg.ReviewedBy,
		arg.ReviewNotes,
		arg.IndicatorID,
	)
	return err
}

const rejectReport = `-- name: RejectReport :exec
UPDATE community_reports
SET
    status = 'rejected',
    reviewed_by = $2,
    reviewed_at = NOW(),
    review_notes = $3,
    updated_at = NOW()
WHERE id = $1
`

type RejectReportParams struct {
	ID          uuid.UUID   `db:"id" json:"id"`
	ReviewedBy  pgtype.UUID `db:"reviewed_by" json:"reviewed_by"`
	ReviewNotes pgtype.Text `db:"review_notes" json:"review_notes"`
}

func (q *Queries) RejectReport(ctx context.Context, arg *RejectReportParams) error {
	_, err := q.db.Exec(ctx, rejectReport, arg.ID, arg.ReviewedBy, arg.ReviewNotes)
	return err
}

const updateReportStatus = `-- name: UpdateReportStatus :exec
UPDATE community_reports
SET
    status = $2,
    reviewed_by = $3,
    reviewed_at = NOW(),
    review_notes = $4,
    updated_at = NOW()
WHERE id = $1
`

type UpdateReportStatusParams struct {
	ID          uuid.UUID           `db:"id" json:"id"`
	Status      models.ReportStatus `db:"status" json:"status"`
	ReviewedBy  pgtype.UUID         `db:"reviewed_by" json:"reviewed_by"`
	ReviewNotes pgtype.Text         `db:"review_notes" json:"review_notes"`
}

func (q *Queries) UpdateReportStatus(ctx context.Context, arg *UpdateReportStatusParams) error {
	_, err := q.db.Exec(ctx, updateReportStatus,
		arg.ID,
		arg.Status,
		arg.ReviewedBy,
		arg.ReviewNotes,
	)
	return err
}
