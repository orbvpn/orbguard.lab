// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: indicators.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"orbguard-lab/internal/domain/models"
)

const addIndicatorSource = `-- name: AddIndicatorSource :exec
INSERT INTO indicator_sources (indicator_id, source_id, source_confidence, raw_data, fetched_at)
VALUES ($1, $2, $3, $4, NOW())
ON CONFLICT (indicator_id, source_id) DO UPDATE SET
    source_confidence = EXCLUDED.source_confidence,
    fetched_at = NOW()
`

type AddIndicatorSourceParams struct {
	IndicatorID      uuid.UUID      `db:"indicator_id" json:"indicator_id"`
	SourceID         uuid.UUID      `db:"source_id" json:"source_id"`
	SourceConfidence pgtype.Numeric `db:"source_confidence" json:"source_confidence"`
	RawData          pgtype.Text    `db:"raw_data" json:"raw_data"`
}

func (q *Queries) AddIndicatorSource(ctx context.Context, arg *AddIndicatorSourceParams) error {
	_, err := q.db.Exec(ctx, addIndicatorSource,
		arg.IndicatorID,
		arg.SourceID,
		arg.SourceConfidence,
		arg.RawData,
	)
	return err
}

const countIndicators = `-- name: CountIndicators :one
SELECT COUNT(*) FROM indicators
`

func (q *Queries) CountIndicators(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countIndicators)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countIndicatorsBySeverity = `-- name: CountIndicatorsBySeverity :one
SELECT COUNT(*) FROM indicators WHERE severity = $1
`

func (q *Queries) CountIndicatorsBySeverity(ctx context.Context, severity models.Severity) (int64, error) {
	row := q.db.QueryRow(ctx, countIndicatorsBySeverity, severity)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countIndicatorsByType = `-- name: CountIndicatorsByType :one
SELECT COUNT(*) FROM indicators WHERE type = $1
`

func (q *Queries) CountIndicatorsByType(ctx context.Context, type_ models.IndicatorType) (int64, error) {
	row := q.db.QueryRow(ctx, countIndicatorsByType, type_)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMobileIndicators = `-- name: CountMobileIndicators :one
SELECT COUNT(*) FROM indicators
WHERE 'android' = ANY(platforms) OR 'ios' = ANY(platforms)
`

func (q *Queries) CountMobileIndicators(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countMobileIndicators)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countPegasusIndicators = `-- name: CountPegasusIndicators :one
SELECT COUNT(*) FROM indicators
WHERE 'pegasus' = ANY(tags) OR 'nso-group' = ANY(tags)
`

func (q *Queries) CountPegasusIndicators(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countPegasusIndicators)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createIndicator = `-- name: CreateIndicator :one
INSERT INTO indicators (
    value, value_hash, type, severity, confidence, description,
    tags, platforms, first_seen, last_seen, expires_at,
    campaign_id, threat_actor_id, malware_family_id,
    mitre_techniques, mitre_tactics, cve_ids, report_count, source_count, metadata
) VALUES (
    $1, $2, $3, $4, $5, $6,
    $7, $8, $9, $10, $11,
    $12, $13, $14,
    $15, $16, $17, $18, $19, $20
)
RETURNING id, value, value_hash, type::text, severity::text, confidence, description,
    tags, platforms::text[], first_seen, last_seen, expires_at,
    campaign_id, threat_actor_id, malware_family_id,
    mitre_techniques, mitre_tactics, cve_ids, report_count, source_count, metadata,
    graph_node_id, created_at, updated_at
`

type CreateIndicatorParams struct {
	Value           string               `db:"value" json:"value"`
	ValueHash       string               `db:"value_hash" json:"value_hash"`
	Type            models.IndicatorType `db:"type" json:"type"`
	Severity        models.Severity      `db:"severity" json:"severity"`
	Confidence      pgtype.Numeric       `db:"confidence" json:"confidence"`
	Description     pgtype.Text          `db:"description" json:"description"`
	Tags            []string             `db:"tags" json:"tags"`
	Platforms       []models.Platform    `db:"platforms" json:"platforms"`
	FirstSeen       pgtype.Timestamptz   `db:"first_seen" json:"first_seen"`
	LastSeen        pgtype.Timestamptz   `db:"last_seen" json:"last_seen"`
	ExpiresAt       pgtype.Timestamptz   `db:"expires_at" json:"expires_at"`
	CampaignID      pgtype.UUID          `db:"campaign_id" json:"campaign_id"`
	ThreatActorID   pgtype.UUID          `db:"threat_actor_id" json:"threat_actor_id"`
	MalwareFamilyID pgtype.UUID          `db:"malware_family_id" json:"malware_family_id"`
	MitreTechniques []string             `db:"mitre_techniques" json:"mitre_techniques"`
	MitreTactics    []string             `db:"mitre_tactics" json:"mitre_tactics"`
	CveIds          []string             `db:"cve_ids" json:"cve_ids"`
	ReportCount     int32                `db:"report_count" json:"report_count"`
	SourceCount     int32                `db:"source_count" json:"source_count"`
	Metadata        []byte               `db:"metadata" json:"metadata"`
}

type CreateIndicatorRow struct {
	ID              uuid.UUID          `db:"id" json:"id"`
	Value           string             `db:"value" json:"value"`
	ValueHash       string             `db:"value_hash" json:"value_hash"`
	Type            string             `db:"type" json:"type"`
	Severity        string             `db:"severity" json:"severity"`
	Confidence      pgtype.Numeric     `db:"confidence" json:"confidence"`
	Description     pgtype.Text        `db:"description" json:"description"`
	Tags            []string           `db:"tags" json:"tags"`
	Platforms       []string           `db:"platforms" json:"platforms"`
	FirstSeen       pgtype.Timestamptz `db:"first_seen" json:"first_seen"`
	LastSeen        pgtype.Timestamptz `db:"last_seen" json:"last_seen"`
	ExpiresAt       pgtype.Timestamptz `db:"expires_at" json:"expires_at"`
	CampaignID      pgtype.UUID        `db:"campaign_id" json:"campaign_id"`
	ThreatActorID   pgtype.UUID        `db:"threat_actor_id" json:"threat_actor_id"`
	MalwareFamilyID pgtype.UUID        `db:"malware_family_id" json:"malware_family_id"`
	MitreTechniques []string           `db:"mitre_techniques" json:"mitre_techniques"`
	MitreTactics    []string           `db:"mitre_tactics" json:"mitre_tactics"`
	CveIds          []string           `db:"cve_ids" json:"cve_ids"`
	ReportCount     int32              `db:"report_count" json:"report_count"`
	SourceCount     int32              `db:"source_count" json:"source_count"`
	Metadata        []byte             `db:"metadata" json:"metadata"`
	GraphNodeID     pgtype.Text        `db:"graph_node_id" json:"graph_node_id"`
	CreatedAt       pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) CreateIndicator(ctx context.Context, arg *CreateIndicatorParams) (*CreateIndicatorRow, error) {
	row := q.db.QueryRow(ctx, createIndicator,
		arg.Value,
		arg.ValueHash,
		arg.Type,
		arg.Severity,
		arg.Confidence,
		arg.Description,
		arg.Tags,
		arg.Platforms,
		arg.FirstSeen,
		arg.LastSeen,
		arg.ExpiresAt,
		arg.CampaignID,
		arg.ThreatActorID,
		arg.MalwareFamilyID,
		arg.MitreTechniques,
		arg.MitreTactics,
		arg.CveIds,
		arg.ReportCount,
		arg.SourceCount,
		arg.Metadata,
	)
	var i CreateIndicatorRow
	err := row.Scan(
		&i.ID,
		&i.Value,
		&i.ValueHash,
		&i.Type,
		&i.Severity,
		&i.Confidence,
		&i.Description,
		&i.Tags,
		&i.Platforms,
		&i.FirstSeen,
		&i.LastSeen,
		&i.ExpiresAt,
		&i.CampaignID,
		&i.ThreatActorID,
		&i.MalwareFamilyID,
		&i.MitreTechniques,
		&i.MitreTactics,
		&i.CveIds,
		&i.ReportCount,
		&i.SourceCount,
		&i.Metadata,
		&i.GraphNodeID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const deleteExpiredIndicators = `-- name: DeleteExpiredIndicators :execrows
DELETE FROM indicators
WHERE expires_at IS NOT NULL AND expires_at < NOW()
`

func (q *Queries) DeleteExpiredIndicators(ctx context.Context) (int64, error) {
	result, err := q.db.Exec(ctx, deleteExpiredIndicators)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteIndicator = `-- name: DeleteIndicator :exec
DELETE FROM indicators WHERE id = $1
`

func (q *Queries) DeleteIndicator(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteIndicator, id)
	return err
}

const getIndicatorByHash = `-- name: GetIndicatorByHash :one
SELECT
    id, value, value_hash, type::text, severity::text, confidence, description,
    tags, platforms::text[], first_seen, last_seen, expires_at,
    campaign_id, threat_actor_id, malware_family_id,
    mitre_techniques, mitre_tactics, cve_ids, report_count, source_count, metadata,
    graph_node_id, created_at, updated_at
FROM indicators WHERE value_hash = $1
`

type GetIndicatorByHashRow struct {
	ID              uuid.UUID          `db:"id" json:"id"`
	Value           string             `db:"value" json:"value"`
	ValueHash       string             `db:"value_hash" json:"value_hash"`
	Type            string             `db:"type" json:"type"`
	Severity        string             `db:"severity" json:"severity"`
	Confidence      pgtype.Numeric     `db:"confidence" json:"confidence"`
	Description     pgtype.Text        `db:"description" json:"description"`
	Tags            []string           `db:"tags" json:"tags"`
	Platforms       []string           `db:"platforms" json:"platforms"`
	FirstSeen       pgtype.Timestamptz `db:"first_seen" json:"first_seen"`
	LastSeen        pgtype.Timestamptz `db:"last_seen" json:"last_seen"`
	ExpiresAt       pgtype.Timestamptz `db:"expires_at" json:"expires_at"`
	CampaignID      pgtype.UUID        `db:"campaign_id" json:"campaign_id"`
	ThreatActorID   pgtype.UUID        `db:"threat_actor_id" json:"threat_actor_id"`
	MalwareFamilyID pgtype.UUID        `db:"malware_family_id" json:"malware_family_id"`
	MitreTechniques []string           `db:"mitre_techniques" json:"mitre_techniques"`
	MitreTactics    []string           `db:"mitre_tactics" json:"mitre_tactics"`
	CveIds          []string           `db:"cve_ids" json:"cve_ids"`
	ReportCount     int32              `db:"report_count" json:"report_count"`
	SourceCount     int32              `db:"source_count" json:"source_count"`
	Metadata        []byte             `db:"metadata" json:"metadata"`
	GraphNodeID     pgtype.Text        `db:"graph_node_id" json:"graph_node_id"`
	CreatedAt       pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) GetIndicatorByHash(ctx context.Context, valueHash string) (*GetIndicatorByHashRow, error) {
	row := q.db.QueryRow(ctx, getIndicatorByHash, valueHash)
	var i GetIndicatorByHashRow
	err := row.Scan(
		&i.ID,
		&i.Value,
		&i.ValueHash,
		&i.Type,
		&i.Severity,
		&i.Confidence,
		&i.Description,
		&i.Tags,
		&i.Platforms,
		&i.FirstSeen,
		&i.LastSeen,
		&i.ExpiresAt,
		&i.CampaignID,
		&i.ThreatActorID,
		&i.MalwareFamilyID,
		&i.MitreTechniques,
		&i.MitreTactics,
		&i.CveIds,
		&i.ReportCount,
		&i.SourceCount,
		&i.Metadata,
		&i.GraphNodeID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getIndicatorByID = `-- name: GetIndicatorByID :one
SELECT
    id, value, value_hash, type::text, severity::text, confidence, description,
    tags, platforms::text[], first_seen, last_seen, expires_at,
    campaign_id, threat_actor_id, malware_family_id,
    mitre_techniques, mitre_tactics, cve_ids, report_count, source_count, metadata,
    graph_node_id, created_at, updated_at
FROM indicators WHERE id = $1
`

type GetIndicatorByIDRow struct {
	ID              uuid.UUID          `db:"id" json:"id"`
	Value           string             `db:"value" json:"value"`
	ValueHash       string             `db:"value_hash" json:"value_hash"`
	Type            string             `db:"type" json:"type"`
	Severity        string             `db:"severity" json:"severity"`
	Confidence      pgtype.Numeric     `db:"confidence" json:"confidence"`
	Description     pgtype.Text        `db:"description" json:"description"`
	Tags            []string           `db:"tags" json:"tags"`
	Platforms       []string           `db:"platforms" json:"platforms"`
	FirstSeen       pgtype.Timestamptz `db:"first_seen" json:"first_seen"`
	LastSeen        pgtype.Timestamptz `db:"last_seen" json:"last_seen"`
	ExpiresAt       pgtype.Timestamptz `db:"expires_at" json:"expires_at"`
	CampaignID      pgtype.UUID        `db:"campaign_id" json:"campaign_id"`
	ThreatActorID   pgtype.UUID        `db:"threat_actor_id" json:"threat_actor_id"`
	MalwareFamilyID pgtype.UUID        `db:"malware_family_id" json:"malware_family_id"`
	MitreTechniques []string           `db:"mitre_techniques" json:"mitre_techniques"`
	MitreTactics    []string           `db:"mitre_tactics" json:"mitre_tactics"`
	CveIds          []string           `db:"cve_ids" json:"cve_ids"`
	ReportCount     int32              `db:"report_count" json:"report_count"`
	SourceCount     int32              `db:"source_count" json:"source_count"`
	Metadata        []byte             `db:"metadata" json:"metadata"`
	GraphNodeID     pgtype.Text        `db:"graph_node_id" json:"graph_node_id"`
	CreatedAt       pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) GetIndicatorByID(ctx context.Context, id uuid.UUID) (*GetIndicatorByIDRow, error) {
	row := q.db.QueryRow(ctx, getIndicatorByID, id)
	var i GetIndicatorByIDRow
	err := row.Scan(
		&i.ID,
		&i.Value,
		&i.ValueHash,
		&i.Type,
		&i.Severity,
		&i.Confidence,
		&i.Description,
		&i.Tags,
		&i.Platforms,
		&i.FirstSeen,
		&i.LastSeen,
		&i.ExpiresAt,
		&i.CampaignID,
		&i.ThreatActorID,
		&i.MalwareFamilyID,
		&i.MitreTechniques,
		&i.MitreTactics,
		&i.CveIds,
		&i.ReportCount,
		&i.SourceCount,
		&i.Metadata,
		&i.GraphNodeID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getIndicatorByValue = `-- name: GetIndicatorByValue :one
SELECT
    id, value, value_hash, type::text, severity::text, confidence, description,
    tags, platforms::text[], first_seen, last_seen, expires_at,
    campaign_id, threat_actor_id, malware_family_id,
    mitre_techniques, mitre_tactics, cve_ids, report_count, source_count, metadata,
    graph_node_id, created_at, updated_at
FROM indicators WHERE value = $1 AND type = $2
`

type GetIndicatorByValueParams struct {
	Value string               `db:"value" json:"value"`
	Type  models.IndicatorType `db:"type" json:"type"`
}

type GetIndicatorByValueRow struct {
	ID              uuid.UUID          `db:"id" json:"id"`
	Value           string             `db:"value" json:"value"`
	ValueHash       string             `db:"value_hash" json:"value_hash"`
	Type            string             `db:"type" json:"type"`
	Severity        string             `db:"severity" json:"severity"`
	Confidence      pgtype.Numeric     `db:"confidence" json:"confidence"`
	Description     pgtype.Text        `db:"description" json:"description"`
	Tags            []string           `db:"tags" json:"tags"`
	Platforms       []string           `db:"platforms" json:"platforms"`
	FirstSeen       pgtype.Timestamptz `db:"first_seen" json:"first_seen"`
	LastSeen        pgtype.Timestamptz `db:"last_seen" json:"last_seen"`
	ExpiresAt       pgtype.Timestamptz `db:"expires_at" json:"expires_at"`
	CampaignID      pgtype.UUID        `db:"campaign_id" json:"campaign_id"`
	ThreatActorID   pgtype.UUID        `db:"threat_actor_id" json:"threat_actor_id"`
	MalwareFamilyID pgtype.UUID        `db:"malware_family_id" json:"malware_family_id"`
	MitreTechniques []string           `db:"mitre_techniques" json:"mitre_techniques"`
	MitreTactics    []string           `db:"mitre_tactics" json:"mitre_tactics"`
	CveIds          []string           `db:"cve_ids" json:"cve_ids"`
	ReportCount     int32              `db:"report_count" json:"report_count"`
	SourceCount     int32              `db:"source_count" json:"source_count"`
	Metadata        []byte             `db:"metadata" json:"metadata"`
	GraphNodeID     pgtype.Text        `db:"graph_node_id" json:"graph_node_id"`
	CreatedAt       pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) GetIndicatorByValue(ctx context.Context, arg *GetIndicatorByValueParams) (*GetIndicatorByValueRow, error) {
	row := q.db.QueryRow(ctx, getIndicatorByValue, arg.Value, arg.Type)
	var i GetIndicatorByValueRow
	err := row.Scan(
		&i.ID,
		&i.Value,
		&i.ValueHash,
		&i.Type,
		&i.Severity,
		&i.Confidence,
		&i.Description,
		&i.Tags,
		&i.Platforms,
		&i.FirstSeen,
		&i.LastSeen,
		&i.ExpiresAt,
		&i.CampaignID,
		&i.ThreatActorID,
		&i.MalwareFamilyID,
		&i.MitreTechniques,
		&i.MitreTactics,
		&i.CveIds,
		&i.ReportCount,
		&i.SourceCount,
		&i.Metadata,
		&i.GraphNodeID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getIndicatorSources = `-- name: GetIndicatorSources :many
SELECT
    isrc.indicator_id,
    isrc.source_id,
    s.name as source_name,
    isrc.source_confidence,
    isrc.fetched_at,
    isrc.created_at
FROM indicator_sources isrc
JOIN sources s ON s.id = isrc.source_id
WHERE isrc.indicator_id = $1
ORDER BY isrc.fetched_at DESC
`

type GetIndicatorSourcesRow struct {
	IndicatorID      uuid.UUID          `db:"indicator_id" json:"indicator_id"`
	SourceID         uuid.UUID          `db:"source_id" json:"source_id"`
	SourceName       string             `db:"source_name" json:"source_name"`
	SourceConfidence pgtype.Numeric     `db:"source_confidence" json:"source_confidence"`
	FetchedAt        pgtype.Timestamptz `db:"fetched_at" json:"fetched_at"`
	CreatedAt        pgtype.Timestamptz `db:"created_at" json:"created_at"`
}

func (q *Queries) GetIndicatorSources(ctx context.Context, indicatorID uuid.UUID) ([]*GetIndicatorSourcesRow, error) {
	rows, err := q.db.Query(ctx, getIndicatorSources, indicatorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetIndicatorSourcesRow{}
	for rows.Next() {
		var i GetIndicatorSourcesRow
		if err := rows.Scan(
			&i.IndicatorID,
			&i.SourceID,
			&i.SourceName,
			&i.SourceConfidence,
			&i.FetchedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIndicatorStats = `-- name: GetIndicatorStats :one
SELECT
    COUNT(*) as total,
    COUNT(*) FILTER (WHERE type = 'domain') as domains,
    COUNT(*) FILTER (WHERE type = 'ip') as ips,
    COUNT(*) FILTER (WHERE type = 'hash') as hashes,
    COUNT(*) FILTER (WHERE type = 'url') as urls,
    COUNT(*) FILTER (WHERE type = 'process') as processes,
    COUNT(*) FILTER (WHERE type = 'package') as packages,
    COUNT(*) FILTER (WHERE severity = 'critical') as critical,
    COUNT(*) FILTER (WHERE severity = 'high') as high,
    COUNT(*) FILTER (WHERE severity = 'medium') as medium,
    COUNT(*) FILTER (WHERE severity = 'low') as low,
    COUNT(*) FILTER (WHERE 'pegasus' = ANY(tags)) as pegasus,
    COUNT(*) FILTER (WHERE 'android' = ANY(platforms) OR 'ios' = ANY(platforms)) as mobile,
    COUNT(*) FILTER (WHERE first_seen >= NOW() - INTERVAL '1 day') as today_new,
    COUNT(*) FILTER (WHERE first_seen >= NOW() - INTERVAL '7 days') as week_new,
    COUNT(*) FILTER (WHERE first_seen >= NOW() - INTERVAL '30 days') as month_new
FROM indicators
`

type GetIndicatorStatsRow struct {
	Total     int64 `db:"total" json:"total"`
	Domains   int64 `db:"domains" json:"domains"`
	Ips       int64 `db:"ips" json:"ips"`
	Hashes    int64 `db:"hashes" json:"hashes"`
	Urls      int64 `db:"urls" json:"urls"`
	Processes int64 `db:"processes" json:"processes"`
	Packages  int64 `db:"packages" json:"packages"`
	Critical  int64 `db:"critical" json:"critical"`
	High      int64 `db:"high" json:"high"`
	Medium    int64 `db:"medium" json:"medium"`
	Low       int64 `db:"low" json:"low"`
	Pegasus   int64 `db:"pegasus" json:"pegasus"`
	Mobile    int64 `db:"mobile" json:"mobile"`
	TodayNew  int64 `db:"today_new" json:"today_new"`
	WeekNew   int64 `db:"week_new" json:"week_new"`
	MonthNew  int64 `db:"month_new" json:"month_new"`
}

func (q *Queries) GetIndicatorStats(ctx context.Context) (*GetIndicatorStatsRow, error) {
	row := q.db.QueryRow(ctx, getIndicatorStats)
	var i GetIndicatorStatsRow
	err := row.Scan(
		&i.Total,
		&i.Domains,
		&i.Ips,
		&i.Hashes,
		&i.Urls,
		&i.Processes,
		&i.Packages,
		&i.Critical,
		&i.High,
		&i.Medium,
		&i.Low,
		&i.Pegasus,
		&i.Mobile,
		&i.TodayNew,
		&i.WeekNew,
		&i.MonthNew,
	)
	return &i, err
}

const incrementIndicatorReportCount = `-- name: IncrementIndicatorReportCount :exec
UPDATE indicators
SET report_count = report_count + 1, updated_at = NOW()
WHERE id = $1
`

func (q *Queries) IncrementIndicatorReportCount(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, incrementIndicatorReportCount, id)
	return err
}

const incrementIndicatorSourceCount = `-- name: IncrementIndicatorSourceCount :exec
UPDATE indicators
SET source_count = source_count + 1, updated_at = NOW()
WHERE id = $1
`

func (q *Queries) IncrementIndicatorSourceCount(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, incrementIndicatorSourceCount, id)
	return err
}

const listActiveIndicators = `-- name: ListActiveIndicators :many
SELECT
    id, value, value_hash, type::text, severity::text, confidence, description,
    tags, platforms::text[], first_seen, last_seen, expires_at,
    campaign_id, threat_actor_id, malware_family_id,
    mitre_techniques, mitre_tactics, cve_ids, report_count, source_count, metadata,
    graph_node_id, created_at, updated_at
FROM indicators
WHERE (expires_at IS NULL OR expires_at > NOW())
ORDER BY last_seen DESC
LIMIT $1 OFFSET $2
`

type ListActiveIndicatorsParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

type ListActiveIndicatorsRow struct {
	ID              uuid.UUID          `db:"id" json:"id"`
	Value           string             `db:"value" json:"value"`
	ValueHash       string             `db:"value_hash" json:"value_hash"`
	Type            string             `db:"type" json:"type"`
	Severity        string             `db:"severity" json:"severity"`
	Confidence      pgtype.Numeric     `db:"confidence" json:"confidence"`
	Description     pgtype.Text        `db:"description" json:"description"`
	Tags            []string           `db:"tags" json:"tags"`
	Platforms       []string           `db:"platforms" json:"platforms"`
	FirstSeen       pgtype.Timestamptz `db:"first_seen" json:"first_seen"`
	LastSeen        pgtype.Timestamptz `db:"last_seen" json:"last_seen"`
	ExpiresAt       pgtype.Timestamptz `db:"expires_at" json:"expires_at"`
	CampaignID      pgtype.UUID        `db:"campaign_id" json:"campaign_id"`
	ThreatActorID   pgtype.UUID        `db:"threat_actor_id" json:"threat_actor_id"`
	MalwareFamilyID pgtype.UUID        `db:"malware_family_id" json:"malware_family_id"`
	MitreTechniques []string           `db:"mitre_techniques" json:"mitre_techniques"`
	MitreTactics    []string           `db:"mitre_tactics" json:"mitre_tactics"`
	CveIds          []string           `db:"cve_ids" json:"cve_ids"`
	ReportCount     int32              `db:"report_count" json:"report_count"`
	SourceCount     int32              `db:"source_count" json:"source_count"`
	Metadata        []byte             `db:"metadata" json:"metadata"`
	GraphNodeID     pgtype.Text        `db:"graph_node_id" json:"graph_node_id"`
	CreatedAt       pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) ListActiveIndicators(ctx context.Context, arg *ListActiveIndicatorsParams) ([]*ListActiveIndicatorsRow, error) {
	rows, err := q.db.Query(ctx, listActiveIndicators, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListActiveIndicatorsRow{}
	for rows.Next() {
		var i ListActiveIndicatorsRow
		if err := rows.Scan(
			&i.ID,
			&i.Value,
			&i.ValueHash,
			&i.Type,
			&i.Severity,
			&i.Confidence,
			&i.Description,
			&i.Tags,
			&i.Platforms,
			&i.FirstSeen,
			&i.LastSeen,
			&i.ExpiresAt,
			&i.CampaignID,
			&i.ThreatActorID,
			&i.MalwareFamilyID,
			&i.MitreTechniques,
			&i.MitreTactics,
			&i.CveIds,
			&i.ReportCount,
			&i.SourceCount,
			&i.Metadata,
			&i.GraphNodeID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCriticalIndicators = `-- name: ListCriticalIndicators :many
SELECT
    id, value, value_hash, type::text, severity::text, confidence, description,
    tags, platforms::text[], first_seen, last_seen, expires_at,
    campaign_id, threat_actor_id, malware_family_id,
    mitre_techniques, mitre_tactics, cve_ids, report_count, source_count, metadata,
    graph_node_id, created_at, updated_at
FROM indicators
WHERE severity = 'critical'
  AND (expires_at IS NULL OR expires_at > NOW())
ORDER BY confidence DESC, last_seen DESC
LIMIT $1 OFFSET $2
`

type ListCriticalIndicatorsParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

type ListCriticalIndicatorsRow struct {
	ID              uuid.UUID          `db:"id" json:"id"`
	Value           string             `db:"value" json:"value"`
	ValueHash       string             `db:"value_hash" json:"value_hash"`
	Type            string             `db:"type" json:"type"`
	Severity        string             `db:"severity" json:"severity"`
	Confidence      pgtype.Numeric     `db:"confidence" json:"confidence"`
	Description     pgtype.Text        `db:"description" json:"description"`
	Tags            []string           `db:"tags" json:"tags"`
	Platforms       []string           `db:"platforms" json:"platforms"`
	FirstSeen       pgtype.Timestamptz `db:"first_seen" json:"first_seen"`
	LastSeen        pgtype.Timestamptz `db:"last_seen" json:"last_seen"`
	ExpiresAt       pgtype.Timestamptz `db:"expires_at" json:"expires_at"`
	CampaignID      pgtype.UUID        `db:"campaign_id" json:"campaign_id"`
	ThreatActorID   pgtype.UUID        `db:"threat_actor_id" json:"threat_actor_id"`
	MalwareFamilyID pgtype.UUID        `db:"malware_family_id" json:"malware_family_id"`
	MitreTechniques []string           `db:"mitre_techniques" json:"mitre_techniques"`
	MitreTactics    []string           `db:"mitre_tactics" json:"mitre_tactics"`
	CveIds          []string           `db:"cve_ids" json:"cve_ids"`
	ReportCount     int32              `db:"report_count" json:"report_count"`
	SourceCount     int32              `db:"source_count" json:"source_count"`
	Metadata        []byte             `db:"metadata" json:"metadata"`
	GraphNodeID     pgtype.Text        `db:"graph_node_id" json:"graph_node_id"`
	CreatedAt       pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) ListCriticalIndicators(ctx context.Context, arg *ListCriticalIndicatorsParams) ([]*ListCriticalIndicatorsRow, error) {
	rows, err := q.db.Query(ctx, listCriticalIndicators, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListCriticalIndicatorsRow{}
	for rows.Next() {
		var i ListCriticalIndicatorsRow
		if err := rows.Scan(
			&i.ID,
			&i.Value,
			&i.ValueHash,
			&i.Type,
			&i.Severity,
			&i.Confidence,
			&i.Description,
			&i.Tags,
			&i.Platforms,
			&i.FirstSeen,
			&i.LastSeen,
			&i.ExpiresAt,
			&i.CampaignID,
			&i.ThreatActorID,
			&i.MalwareFamilyID,
			&i.MitreTechniques,
			&i.MitreTactics,
			&i.CveIds,
			&i.ReportCount,
			&i.SourceCount,
			&i.Metadata,
			&i.GraphNodeID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listIndicators = `-- name: ListIndicators :many
SELECT
    id, value, value_hash, type::text, severity::text, confidence, description,
    tags, platforms::text[], first_seen, last_seen, expires_at,
    campaign_id, threat_actor_id, malware_family_id,
    mitre_techniques, mitre_tactics, cve_ids, report_count, source_count, metadata,
    graph_node_id, created_at, updated_at
FROM indicators
ORDER BY last_seen DESC
LIMIT $1 OFFSET $2
`

type ListIndicatorsParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

type ListIndicatorsRow struct {
	ID              uuid.UUID          `db:"id" json:"id"`
	Value           string             `db:"value" json:"value"`
	ValueHash       string             `db:"value_hash" json:"value_hash"`
	Type            string             `db:"type" json:"type"`
	Severity        string             `db:"severity" json:"severity"`
	Confidence      pgtype.Numeric     `db:"confidence" json:"confidence"`
	Description     pgtype.Text        `db:"description" json:"description"`
	Tags            []string           `db:"tags" json:"tags"`
	Platforms       []string           `db:"platforms" json:"platforms"`
	FirstSeen       pgtype.Timestamptz `db:"first_seen" json:"first_seen"`
	LastSeen        pgtype.Timestamptz `db:"last_seen" json:"last_seen"`
	ExpiresAt       pgtype.Timestamptz `db:"expires_at" json:"expires_at"`
	CampaignID      pgtype.UUID        `db:"campaign_id" json:"campaign_id"`
	ThreatActorID   pgtype.UUID        `db:"threat_actor_id" json:"threat_actor_id"`
	MalwareFamilyID pgtype.UUID        `db:"malware_family_id" json:"malware_family_id"`
	MitreTechniques []string           `db:"mitre_techniques" json:"mitre_techniques"`
	MitreTactics    []string           `db:"mitre_tactics" json:"mitre_tactics"`
	CveIds          []string           `db:"cve_ids" json:"cve_ids"`
	ReportCount     int32              `db:"report_count" json:"report_count"`
	SourceCount     int32              `db:"source_count" json:"source_count"`
	Metadata        []byte             `db:"metadata" json:"metadata"`
	GraphNodeID     pgtype.Text        `db:"graph_node_id" json:"graph_node_id"`
	CreatedAt       pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) ListIndicators(ctx context.Context, arg *ListIndicatorsParams) ([]*ListIndicatorsRow, error) {
	rows, err := q.db.Query(ctx, listIndicators, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListIndicatorsRow{}
	for rows.Next() {
		var i ListIndicatorsRow
		if err := rows.Scan(
			&i.ID,
			&i.Value,
			&i.ValueHash,
			&i.Type,
			&i.Severity,
			&i.Confidence,
			&i.Description,
			&i.Tags,
			&i.Platforms,
			&i.FirstSeen,
			&i.LastSeen,
			&i.ExpiresAt,
			&i.CampaignID,
			&i.ThreatActorID,
			&i.MalwareFamilyID,
			&i.MitreTechniques,
			&i.MitreTactics,
			&i.CveIds,
			&i.ReportCount,
			&i.SourceCount,
			&i.Metadata,
			&i.GraphNodeID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listIndicatorsByCampaign = `-- name: ListIndicatorsByCampaign :many
SELECT
    id, value, value_hash, type::text, severity::text, confidence, description,
    tags, platforms::text[], first_seen, last_seen, expires_at,
    campaign_id, threat_actor_id, malware_family_id,
    mitre_techniques, mitre_tactics, cve_ids, report_count, source_count, metadata,
    graph_node_id, created_at, updated_at
FROM indicators
WHERE campaign_id = $1
ORDER BY last_seen DESC
LIMIT $2 OFFSET $3
`

type ListIndicatorsByCampaignParams struct {
	CampaignID pgtype.UUID `db:"campaign_id" json:"campaign_id"`
	Limit      int32       `db:"limit" json:"limit"`
	Offset     int32       `db:"offset" json:"offset"`
}

type ListIndicatorsByCampaignRow struct {
	ID              uuid.UUID          `db:"id" json:"id"`
	Value           string             `db:"value" json:"value"`
	ValueHash       string             `db:"value_hash" json:"value_hash"`
	Type            string             `db:"type" json:"type"`
	Severity        string             `db:"severity" json:"severity"`
	Confidence      pgtype.Numeric     `db:"confidence" json:"confidence"`
	Description     pgtype.Text        `db:"description" json:"description"`
	Tags            []string           `db:"tags" json:"tags"`
	Platforms       []string           `db:"platforms" json:"platforms"`
	FirstSeen       pgtype.Timestamptz `db:"first_seen" json:"first_seen"`
	LastSeen        pgtype.Timestamptz `db:"last_seen" json:"last_seen"`
	ExpiresAt       pgtype.Timestamptz `db:"expires_at" json:"expires_at"`
	CampaignID      pgtype.UUID        `db:"campaign_id" json:"campaign_id"`
	ThreatActorID   pgtype.UUID        `db:"threat_actor_id" json:"threat_actor_id"`
	MalwareFamilyID pgtype.UUID        `db:"malware_family_id" json:"malware_family_id"`
	MitreTechniques []string           `db:"mitre_techniques" json:"mitre_techniques"`
	MitreTactics    []string           `db:"mitre_tactics" json:"mitre_tactics"`
	CveIds          []string           `db:"cve_ids" json:"cve_ids"`
	ReportCount     int32              `db:"report_count" json:"report_count"`
	SourceCount     int32              `db:"source_count" json:"source_count"`
	Metadata        []byte             `db:"metadata" json:"metadata"`
	GraphNodeID     pgtype.Text        `db:"graph_node_id" json:"graph_node_id"`
	CreatedAt       pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) ListIndicatorsByCampaign(ctx context.Context, arg *ListIndicatorsByCampaignParams) ([]*ListIndicatorsByCampaignRow, error) {
	rows, err := q.db.Query(ctx, listIndicatorsByCampaign, arg.CampaignID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListIndicatorsByCampaignRow{}
	for rows.Next() {
		var i ListIndicatorsByCampaignRow
		if err := rows.Scan(
			&i.ID,
			&i.Value,
			&i.ValueHash,
			&i.Type,
			&i.Severity,
			&i.Confidence,
			&i.Description,
			&i.Tags,
			&i.Platforms,
			&i.FirstSeen,
			&i.LastSeen,
			&i.ExpiresAt,
			&i.CampaignID,
			&i.ThreatActorID,
			&i.MalwareFamilyID,
			&i.MitreTechniques,
			&i.MitreTactics,
			&i.CveIds,
			&i.ReportCount,
			&i.SourceCount,
			&i.Metadata,
			&i.GraphNodeID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listIndicatorsBySeverity = `-- name: ListIndicatorsBySeverity :many
SELECT
    id, value, value_hash, type::text, severity::text, confidence, description,
    tags, platforms::text[], first_seen, last_seen, expires_at,
    campaign_id, threat_actor_id, malware_family_id,
    mitre_techniques, mitre_tactics, cve_ids, report_count, source_count, metadata,
    graph_node_id, created_at, updated_at
FROM indicators
WHERE severity = $1
ORDER BY last_seen DESC
LIMIT $2 OFFSET $3
`

type ListIndicatorsBySeverityParams struct {
	Severity models.Severity `db:"severity" json:"severity"`
	Limit    int32           `db:"limit" json:"limit"`
	Offset   int32           `db:"offset" json:"offset"`
}

type ListIndicatorsBySeverityRow struct {
	ID              uuid.UUID          `db:"id" json:"id"`
	Value           string             `db:"value" json:"value"`
	ValueHash       string             `db:"value_hash" json:"value_hash"`
	Type            string             `db:"type" json:"type"`
	Severity        string             `db:"severity" json:"severity"`
	Confidence      pgtype.Numeric     `db:"confidence" json:"confidence"`
	Description     pgtype.Text        `db:"description" json:"description"`
	Tags            []string           `db:"tags" json:"tags"`
	Platforms       []string           `db:"platforms" json:"platforms"`
	FirstSeen       pgtype.Timestamptz `db:"first_seen" json:"first_seen"`
	LastSeen        pgtype.Timestamptz `db:"last_seen" json:"last_seen"`
	ExpiresAt       pgtype.Timestamptz `db:"expires_at" json:"expires_at"`
	CampaignID      pgtype.UUID        `db:"campaign_id" json:"campaign_id"`
	ThreatActorID   pgtype.UUID        `db:"threat_actor_id" json:"threat_actor_id"`
	MalwareFamilyID pgtype.UUID        `db:"malware_family_id" json:"malware_family_id"`
	MitreTechniques []string           `db:"mitre_techniques" json:"mitre_techniques"`
	MitreTactics    []string           `db:"mitre_tactics" json:"mitre_tactics"`
	CveIds          []string           `db:"cve_ids" json:"cve_ids"`
	ReportCount     int32              `db:"report_count" json:"report_count"`
	SourceCount     int32              `db:"source_count" json:"source_count"`
	Metadata        []byte             `db:"metadata" json:"metadata"`
	GraphNodeID     pgtype.Text        `db:"graph_node_id" json:"graph_node_id"`
	CreatedAt       pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) ListIndicatorsBySeverity(ctx context.Context, arg *ListIndicatorsBySeverityParams) ([]*ListIndicatorsBySeverityRow, error) {
	rows, err := q.db.Query(ctx, listIndicatorsBySeverity, arg.Severity, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListIndicatorsBySeverityRow{}
	for rows.Next() {
		var i ListIndicatorsBySeverityRow
		if err := rows.Scan(
			&i.ID,
			&i.Value,
			&i.ValueHash,
			&i.Type,
			&i.Severity,
			&i.Confidence,
			&i.Description,
			&i.Tags,
			&i.Platforms,
			&i.FirstSeen,
			&i.LastSeen,
			&i.ExpiresAt,
			&i.CampaignID,
			&i.ThreatActorID,
			&i.MalwareFamilyID,
			&i.MitreTechniques,
			&i.MitreTactics,
			&i.CveIds,
			&i.ReportCount,
			&i.SourceCount,
			&i.Metadata,
			&i.GraphNodeID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listIndicatorsByType = `-- name: ListIndicatorsByType :many
SELECT
    id, value, value_hash, type::text, severity::text, confidence, description,
    tags, platforms::text[], first_seen, last_seen, expires_at,
    campaign_id, threat_actor_id, malware_family_id,
    mitre_techniques, mitre_tactics, cve_ids, report_count, source_count, metadata,
    graph_node_id, created_at, updated_at
FROM indicators
WHERE type = $1
ORDER BY last_seen DESC
LIMIT $2 OFFSET $3
`

type ListIndicatorsByTypeParams struct {
	Type   models.IndicatorType `db:"type" json:"type"`
	Limit  int32                `db:"limit" json:"limit"`
	Offset int32                `db:"offset" json:"offset"`
}

type ListIndicatorsByTypeRow struct {
	ID              uuid.UUID          `db:"id" json:"id"`
	Value           string             `db:"value" json:"value"`
	ValueHash       string             `db:"value_hash" json:"value_hash"`
	Type            string             `db:"type" json:"type"`
	Severity        string             `db:"severity" json:"severity"`
	Confidence      pgtype.Numeric     `db:"confidence" json:"confidence"`
	Description     pgtype.Text        `db:"description" json:"description"`
	Tags            []string           `db:"tags" json:"tags"`
	Platforms       []string           `db:"platforms" json:"platforms"`
	FirstSeen       pgtype.Timestamptz `db:"first_seen" json:"first_seen"`
	LastSeen        pgtype.Timestamptz `db:"last_seen" json:"last_seen"`
	ExpiresAt       pgtype.Timestamptz `db:"expires_at" json:"expires_at"`
	CampaignID      pgtype.UUID        `db:"campaign_id" json:"campaign_id"`
	ThreatActorID   pgtype.UUID        `db:"threat_actor_id" json:"threat_actor_id"`
	MalwareFamilyID pgtype.UUID        `db:"malware_family_id" json:"malware_family_id"`
	MitreTechniques []string           `db:"mitre_techniques" json:"mitre_techniques"`
	MitreTactics    []string           `db:"mitre_tactics" json:"mitre_tactics"`
	CveIds          []string           `db:"cve_ids" json:"cve_ids"`
	ReportCount     int32              `db:"report_count" json:"report_count"`
	SourceCount     int32              `db:"source_count" json:"source_count"`
	Metadata        []byte             `db:"metadata" json:"metadata"`
	GraphNodeID     pgtype.Text        `db:"graph_node_id" json:"graph_node_id"`
	CreatedAt       pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) ListIndicatorsByType(ctx context.Context, arg *ListIndicatorsByTypeParams) ([]*ListIndicatorsByTypeRow, error) {
	rows, err := q.db.Query(ctx, listIndicatorsByType, arg.Type, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListIndicatorsByTypeRow{}
	for rows.Next() {
		var i ListIndicatorsByTypeRow
		if err := rows.Scan(
			&i.ID,
			&i.Value,
			&i.ValueHash,
			&i.Type,
			&i.Severity,
			&i.Confidence,
			&i.Description,
			&i.Tags,
			&i.Platforms,
			&i.FirstSeen,
			&i.LastSeen,
			&i.ExpiresAt,
			&i.CampaignID,
			&i.ThreatActorID,
			&i.MalwareFamilyID,
			&i.MitreTechniques,
			&i.MitreTactics,
			&i.CveIds,
			&i.ReportCount,
			&i.SourceCount,
			&i.Metadata,
			&i.GraphNodeID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMobileIndicators = `-- name: ListMobileIndicators :many
SELECT
    id, value, value_hash, type::text, severity::text, confidence, description,
    tags, platforms::text[], first_seen, last_seen, expires_at,
    campaign_id, threat_actor_id, malware_family_id,
    mitre_techniques, mitre_tactics, cve_ids, report_count, source_count, metadata,
    graph_node_id, created_at, updated_at
FROM indicators
WHERE 'android' = ANY(platforms) OR 'ios' = ANY(platforms)
ORDER BY severity DESC, confidence DESC
LIMIT $1 OFFSET $2
`

type ListMobileIndicatorsParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

type ListMobileIndicatorsRow struct {
	ID              uuid.UUID          `db:"id" json:"id"`
	Value           string             `db:"value" json:"value"`
	ValueHash       string             `db:"value_hash" json:"value_hash"`
	Type            string             `db:"type" json:"type"`
	Severity        string             `db:"severity" json:"severity"`
	Confidence      pgtype.Numeric     `db:"confidence" json:"confidence"`
	Description     pgtype.Text        `db:"description" json:"description"`
	Tags            []string           `db:"tags" json:"tags"`
	Platforms       []string           `db:"platforms" json:"platforms"`
	FirstSeen       pgtype.Timestamptz `db:"first_seen" json:"first_seen"`
	LastSeen        pgtype.Timestamptz `db:"last_seen" json:"last_seen"`
	ExpiresAt       pgtype.Timestamptz `db:"expires_at" json:"expires_at"`
	CampaignID      pgtype.UUID        `db:"campaign_id" json:"campaign_id"`
	ThreatActorID   pgtype.UUID        `db:"threat_actor_id" json:"threat_actor_id"`
	MalwareFamilyID pgtype.UUID        `db:"malware_family_id" json:"malware_family_id"`
	MitreTechniques []string           `db:"mitre_techniques" json:"mitre_techniques"`
	MitreTactics    []string           `db:"mitre_tactics" json:"mitre_tactics"`
	CveIds          []string           `db:"cve_ids" json:"cve_ids"`
	ReportCount     int32              `db:"report_count" json:"report_count"`
	SourceCount     int32              `db:"source_count" json:"source_count"`
	Metadata        []byte             `db:"metadata" json:"metadata"`
	GraphNodeID     pgtype.Text        `db:"graph_node_id" json:"graph_node_id"`
	CreatedAt       pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) ListMobileIndicators(ctx context.Context, arg *ListMobileIndicatorsParams) ([]*ListMobileIndicatorsRow, error) {
	rows, err := q.db.Query(ctx, listMobileIndicators, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListMobileIndicatorsRow{}
	for rows.Next() {
		var i ListMobileIndicatorsRow
		if err := rows.Scan(
			&i.ID,
			&i.Value,
			&i.ValueHash,
			&i.Type,
			&i.Severity,
			&i.Confidence,
			&i.Description,
			&i.Tags,
			&i.Platforms,
			&i.FirstSeen,
			&i.LastSeen,
			&i.ExpiresAt,
			&i.CampaignID,
			&i.ThreatActorID,
			&i.MalwareFamilyID,
			&i.MitreTechniques,
			&i.MitreTactics,
			&i.CveIds,
			&i.ReportCount,
			&i.SourceCount,
			&i.Metadata,
			&i.GraphNodeID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPegasusIndicators = `-- name: ListPegasusIndicators :many
SELECT
    id, value, value_hash, type::text, severity::text, confidence, description,
    tags, platforms::text[], first_seen, last_seen, expires_at,
    campaign_id, threat_actor_id, malware_family_id,
    mitre_techniques, mitre_tactics, cve_ids, report_count, source_count, metadata,
    graph_node_id, created_at, updated_at
FROM indicators
WHERE 'pegasus' = ANY(tags) OR 'nso-group' = ANY(tags)
ORDER BY severity DESC, confidence DESC
LIMIT $1 OFFSET $2
`

type ListPegasusIndicatorsParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

type ListPegasusIndicatorsRow struct {
	ID              uuid.UUID          `db:"id" json:"id"`
	Value           string             `db:"value" json:"value"`
	ValueHash       string             `db:"value_hash" json:"value_hash"`
	Type            string             `db:"type" json:"type"`
	Severity        string             `db:"severity" json:"severity"`
	Confidence      pgtype.Numeric     `db:"confidence" json:"confidence"`
	Description     pgtype.Text        `db:"description" json:"description"`
	Tags            []string           `db:"tags" json:"tags"`
	Platforms       []string           `db:"platforms" json:"platforms"`
	FirstSeen       pgtype.Timestamptz `db:"first_seen" json:"first_seen"`
	LastSeen        pgtype.Timestamptz `db:"last_seen" json:"last_seen"`
	ExpiresAt       pgtype.Timestamptz `db:"expires_at" json:"expires_at"`
	CampaignID      pgtype.UUID        `db:"campaign_id" json:"campaign_id"`
	ThreatActorID   pgtype.UUID        `db:"threat_actor_id" json:"threat_actor_id"`
	MalwareFamilyID pgtype.UUID        `db:"malware_family_id" json:"malware_family_id"`
	MitreTechniques []string           `db:"mitre_techniques" json:"mitre_techniques"`
	MitreTactics    []string           `db:"mitre_tactics" json:"mitre_tactics"`
	CveIds          []string           `db:"cve_ids" json:"cve_ids"`
	ReportCount     int32              `db:"report_count" json:"report_count"`
	SourceCount     int32              `db:"source_count" json:"source_count"`
	Metadata        []byte             `db:"metadata" json:"metadata"`
	GraphNodeID     pgtype.Text        `db:"graph_node_id" json:"graph_node_id"`
	CreatedAt       pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) ListPegasusIndicators(ctx context.Context, arg *ListPegasusIndicatorsParams) ([]*ListPegasusIndicatorsRow, error) {
	rows, err := q.db.Query(ctx, listPegasusIndicators, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListPegasusIndicatorsRow{}
	for rows.Next() {
		var i ListPegasusIndicatorsRow
		if err := rows.Scan(
			&i.ID,
			&i.Value,
			&i.ValueHash,
			&i.Type,
			&i.Severity,
			&i.Confidence,
			&i.Description,
			&i.Tags,
			&i.Platforms,
			&i.FirstSeen,
			&i.LastSeen,
			&i.ExpiresAt,
			&i.CampaignID,
			&i.ThreatActorID,
			&i.MalwareFamilyID,
			&i.MitreTechniques,
			&i.MitreTactics,
			&i.CveIds,
			&i.ReportCount,
			&i.SourceCount,
			&i.Metadata,
			&i.GraphNodeID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchIndicators = `-- name: SearchIndicators :many
SELECT
    id, value, value_hash, type::text, severity::text, confidence, description,
    tags, platforms::text[], first_seen, last_seen, expires_at,
    campaign_id, threat_actor_id, malware_family_id,
    mitre_techniques, mitre_tactics, cve_ids, report_count, source_count, metadata,
    graph_node_id, created_at, updated_at
FROM indicators
WHERE value ILIKE '%' || $1 || '%'
   OR $1 = ANY(tags)
ORDER BY severity DESC, confidence DESC
LIMIT $2 OFFSET $3
`

type SearchIndicatorsParams struct {
	Column1 pgtype.Text `db:"column_1" json:"column_1"`
	Limit   int32       `db:"limit" json:"limit"`
	Offset  int32       `db:"offset" json:"offset"`
}

type SearchIndicatorsRow struct {
	ID              uuid.UUID          `db:"id" json:"id"`
	Value           string             `db:"value" json:"value"`
	ValueHash       string             `db:"value_hash" json:"value_hash"`
	Type            string             `db:"type" json:"type"`
	Severity        string             `db:"severity" json:"severity"`
	Confidence      pgtype.Numeric     `db:"confidence" json:"confidence"`
	Description     pgtype.Text        `db:"description" json:"description"`
	Tags            []string           `db:"tags" json:"tags"`
	Platforms       []string           `db:"platforms" json:"platforms"`
	FirstSeen       pgtype.Timestamptz `db:"first_seen" json:"first_seen"`
	LastSeen        pgtype.Timestamptz `db:"last_seen" json:"last_seen"`
	ExpiresAt       pgtype.Timestamptz `db:"expires_at" json:"expires_at"`
	CampaignID      pgtype.UUID        `db:"campaign_id" json:"campaign_id"`
	ThreatActorID   pgtype.UUID        `db:"threat_actor_id" json:"threat_actor_id"`
	MalwareFamilyID pgtype.UUID        `db:"malware_family_id" json:"malware_family_id"`
	MitreTechniques []string           `db:"mitre_techniques" json:"mitre_techniques"`
	MitreTactics    []string           `db:"mitre_tactics" json:"mitre_tactics"`
	CveIds          []string           `db:"cve_ids" json:"cve_ids"`
	ReportCount     int32              `db:"report_count" json:"report_count"`
	SourceCount     int32              `db:"source_count" json:"source_count"`
	Metadata        []byte             `db:"metadata" json:"metadata"`
	GraphNodeID     pgtype.Text        `db:"graph_node_id" json:"graph_node_id"`
	CreatedAt       pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) SearchIndicators(ctx context.Context, arg *SearchIndicatorsParams) ([]*SearchIndicatorsRow, error) {
	rows, err := q.db.Query(ctx, searchIndicators, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SearchIndicatorsRow{}
	for rows.Next() {
		var i SearchIndicatorsRow
		if err := rows.Scan(
			&i.ID,
			&i.Value,
			&i.ValueHash,
			&i.Type,
			&i.Severity,
			&i.Confidence,
			&i.Description,
			&i.Tags,
			&i.Platforms,
			&i.FirstSeen,
			&i.LastSeen,
			&i.ExpiresAt,
			&i.CampaignID,
			&i.ThreatActorID,
			&i.MalwareFamilyID,
			&i.MitreTechniques,
			&i.MitreTactics,
			&i.CveIds,
			&i.ReportCount,
			&i.SourceCount,
			&i.Metadata,
			&i.GraphNodeID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateIndicatorConfidence = `-- name: UpdateIndicatorConfidence :exec
UPDATE indicators
SET confidence = $2, updated_at = NOW()
WHERE id = $1
`

type UpdateIndicatorConfidenceParams struct {
	ID         uuid.UUID      `db:"id" json:"id"`
	Confidence pgtype.Numeric `db:"confidence" json:"confidence"`
}

func (q *Queries) UpdateIndicatorConfidence(ctx context.Context, arg *UpdateIndicatorConfidenceParams) error {
	_, err := q.db.Exec(ctx, updateIndicatorConfidence, arg.ID, arg.Confidence)
	return err
}

const updateIndicatorLastSeen = `-- name: UpdateIndicatorLastSeen :exec
UPDATE indicators
SET last_seen = NOW(), updated_at = NOW()
WHERE id = $1
`

func (q *Queries) UpdateIndicatorLastSeen(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, updateIndicatorLastSeen, id)
	return err
}

const upsertIndicator = `-- name: UpsertIndicator :one
INSERT INTO indicators (
    value, value_hash, type, severity, confidence, description,
    tags, platforms, first_seen, last_seen,
    campaign_id, threat_actor_id, malware_family_id,
    mitre_techniques, mitre_tactics, cve_ids
) VALUES (
    $1, $2, $3, $4, $5, $6,
    $7, $8, $9, $10,
    $11, $12, $13,
    $14, $15, $16
)
ON CONFLICT (value_hash) DO UPDATE SET
    last_seen = EXCLUDED.last_seen,
    confidence = GREATEST(indicators.confidence, EXCLUDED.confidence),
    source_count = indicators.source_count + 1,
    updated_at = NOW()
RETURNING id, value, value_hash, type::text, severity::text, confidence, description,
    tags, platforms::text[], first_seen, last_seen, expires_at,
    campaign_id, threat_actor_id, malware_family_id,
    mitre_techniques, mitre_tactics, cve_ids, report_count, source_count, metadata,
    graph_node_id, created_at, updated_at
`

type UpsertIndicatorParams struct {
	Value           string               `db:"value" json:"value"`
	ValueHash       string               `db:"value_hash" json:"value_hash"`
	Type            models.IndicatorType `db:"type" json:"type"`
	Severity        models.Severity      `db:"severity" json:"severity"`
	Confidence      pgtype.Numeric       `db:"confidence" json:"confidence"`
	Description     pgtype.Text          `db:"description" json:"description"`
	Tags            []string             `db:"tags" json:"tags"`
	Platforms       []models.Platform    `db:"platforms" json:"platforms"`
	FirstSeen       pgtype.Timestamptz   `db:"first_seen" json:"first_seen"`
	LastSeen        pgtype.Timestamptz   `db:"last_seen" json:"last_seen"`
	CampaignID      pgtype.UUID          `db:"campaign_id" json:"campaign_id"`
	ThreatActorID   pgtype.UUID          `db:"threat_actor_id" json:"threat_actor_id"`
	MalwareFamilyID pgtype.UUID          `db:"malware_family_id" json:"malware_family_id"`
	MitreTechniques []string             `db:"mitre_techniques" json:"mitre_techniques"`
	MitreTactics    []string             `db:"mitre_tactics" json:"mitre_tactics"`
	CveIds          []string             `db:"cve_ids" json:"cve_ids"`
}

type UpsertIndicatorRow struct {
	ID              uuid.UUID          `db:"id" json:"id"`
	Value           string             `db:"value" json:"value"`
	ValueHash       string             `db:"value_hash" json:"value_hash"`
	Type            string             `db:"type" json:"type"`
	Severity        string             `db:"severity" json:"severity"`
	Confidence      pgtype.Numeric     `db:"confidence" json:"confidence"`
	Description     pgtype.Text        `db:"description" json:"description"`
	Tags            []string           `db:"tags" json:"tags"`
	Platforms       []string           `db:"platforms" json:"platforms"`
	FirstSeen       pgtype.Timestamptz `db:"first_seen" json:"first_seen"`
	LastSeen        pgtype.Timestamptz `db:"last_seen" json:"last_seen"`
	ExpiresAt       pgtype.Timestamptz `db:"expires_at" json:"expires_at"`
	CampaignID      pgtype.UUID        `db:"campaign_id" json:"campaign_id"`
	ThreatActorID   pgtype.UUID        `db:"threat_actor_id" json:"threat_actor_id"`
	MalwareFamilyID pgtype.UUID        `db:"malware_family_id" json:"malware_family_id"`
	MitreTechniques []string           `db:"mitre_techniques" json:"mitre_techniques"`
	MitreTactics    []string           `db:"mitre_tactics" json:"mitre_tactics"`
	CveIds          []string           `db:"cve_ids" json:"cve_ids"`
	ReportCount     int32              `db:"report_count" json:"report_count"`
	SourceCount     int32              `db:"source_count" json:"source_count"`
	Metadata        []byte             `db:"metadata" json:"metadata"`
	GraphNodeID     pgtype.Text        `db:"graph_node_id" json:"graph_node_id"`
	CreatedAt       pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) UpsertIndicator(ctx context.Context, arg *UpsertIndicatorParams) (*UpsertIndicatorRow, error) {
	row := q.db.QueryRow(ctx, upsertIndicator,
		arg.Value,
		arg.ValueHash,
		arg.Type,
		arg.Severity,
		arg.Confidence,
		arg.Description,
		arg.Tags,
		arg.Platforms,
		arg.FirstSeen,
		arg.LastSeen,
		arg.CampaignID,
		arg.ThreatActorID,
		arg.MalwareFamilyID,
		arg.MitreTechniques,
		arg.MitreTactics,
		arg.CveIds,
	)
	var i UpsertIndicatorRow
	err := row.Scan(
		&i.ID,
		&i.Value,
		&i.ValueHash,
		&i.Type,
		&i.Severity,
		&i.Confidence,
		&i.Description,
		&i.Tags,
		&i.Platforms,
		&i.FirstSeen,
		&i.LastSeen,
		&i.ExpiresAt,
		&i.CampaignID,
		&i.ThreatActorID,
		&i.MalwareFamilyID,
		&i.MitreTechniques,
		&i.MitreTactics,
		&i.CveIds,
		&i.ReportCount,
		&i.SourceCount,
		&i.Metadata,
		&i.GraphNodeID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
